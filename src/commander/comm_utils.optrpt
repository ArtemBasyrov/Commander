Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.

Intel(R) Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 18.0.3.222 Build 20180410

Compiler options: -I/mn/stornext/u3/hke/owl/local/src/dagsshealpix/include -I/mn/stornext/u3/hke/owl/local/include -I/astro/local/opt/Intel/compilers_and_libraries_2018.3.222/linux/mpi/intel64/include -I/astro/local/opt/Intel/compilers_and_libraries_2018.3.222/linux/mpi/intel64/include -O3 -traceback -qopenmp -qopt-report=5 -parallel -c

    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: false
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: false

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

Begin optimization report for: comm_utils._

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (comm_utils._) [1/28=3.6%] comm_utils.f90(1,8)


    Report from: Code generation optimizations [cg]

comm_utils.f90(1,8):remark #34051: REGISTER ALLOCATION : [comm_utils._] comm_utils.f90:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    0[ reg_null]
        
    Routine temporaries
        Total         :       6
            Global    :       0
            Local     :       6
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::GETLUN

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::GETLUN) [2/28=7.1%] comm_utils.f90(28,12)
  -> EXTERN: (35,16) for_inquire
  -> EXTERN: (37,19) for_inquire


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(32,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(28,12):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_getlun_] comm_utils.f90:28

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8 r12-r14]
        
    Routine temporaries
        Total         :      28
            Global    :      15
            Local     :      13
        Regenerable   :      18
        Spilled       :       3
        
    Routine stack
        Variables     :      88 bytes*
            Reads     :       2 [3.64e+01 ~ 8.0%]
            Writes    :       4 [7.28e+01 ~ 16.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::READ_BEAM

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::READ_BEAM) [3/28=10.7%] comm_utils.f90(43,14)
  -> EXTERN: (43,37) for_deallocate
  -> EXTERN: (54,5) for_alloc_allocatable
  -> EXTERN: (54,5) for_check_mult_overflow64
  -> EXTERN: (57,5) for_alloc_allocatable
  -> EXTERN: (57,5) for_check_mult_overflow64
  -> EXTERN: (57,5) for_alloc_allocatable
  -> EXTERN: (57,5) for_check_mult_overflow64
  -> EXTERN: (59,13) FITS2CL_D
  -> EXTERN: (65,13) FITS2CL_D
  -> EXTERN: (67,13) GAUSSBEAM
  -> EXTERN: (85,5) for_dealloc_allocatable
  -> EXTERN: (85,5) for_dealloc_allocatable
  -> EXTERN: (87,3) for_dealloc_allocatable
  -> EXTERN: (87,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(55,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(55,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(55,5)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference beam(:,:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.833
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.550 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(55,5)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(61,8)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized
   remark #25015: Estimate of max trip count of loop=2

   LOOP BEGIN at comm_utils.f90(61,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(61,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference PW(:,:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.833
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.550 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(61,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(69,8)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized
   remark #25015: Estimate of max trip count of loop=4

   LOOP BEGIN at comm_utils.f90(69,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(69,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference BEAM_IN(:,:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.833
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.550 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(69,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(72,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference beam(:,1) has unaligned access
   remark #15388: vectorization support: reference PW(:,1) has aligned access
   remark #15388: vectorization support: reference BEAM_IN(:,1) has aligned access
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.094
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 2 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 6 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 1.480 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(72,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at comm_utils.f90(74,12)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at comm_utils.f90(74,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference BEAM_IN(:,2) has aligned access
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 1.450
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 6 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 2.260 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(74,12)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at comm_utils.f90(76,11)
   remark #25045: Fused Loops: ( 76 77 )

   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference beam(:,2) has unaligned access
   remark #15389: vectorization support: reference PW(:,2) has unaligned access
   remark #15388: vectorization support: reference BEAM_IN(:,1) has aligned access
   remark #15389: vectorization support: reference beam(:,3) has unaligned access   [ comm_utils.f90(77,11) ]
   remark #15389: vectorization support: reference PW(:,2) has unaligned access   [ comm_utils.f90(77,11) ]
   remark #15388: vectorization support: reference BEAM_IN(:,1) has aligned access   [ comm_utils.f90(77,11) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.167
   remark #15301: FUSED LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 2 
   remark #15450: unmasked unaligned unit stride loads: 2 
   remark #15451: unmasked unaligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 13 
   remark #15477: vector cost: 9.000 
   remark #15478: estimated potential speedup: 1.420 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(77,11)
   remark #25046: Loop lost in Fusion 
LOOP END

LOOP BEGIN at comm_utils.f90(76,11)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference beam(:,2) has unaligned access
   remark #15389: vectorization support: reference PW(:,2) has unaligned access
   remark #15388: vectorization support: reference BEAM_IN(:,1) has aligned access
   remark #15389: vectorization support: reference beam(:,3) has unaligned access   [ comm_utils.f90(77,11) ]
   remark #15389: vectorization support: reference PW(:,2) has unaligned access   [ comm_utils.f90(77,11) ]
   remark #15388: vectorization support: reference BEAM_IN(:,1) has aligned access   [ comm_utils.f90(77,11) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.733
LOOP END

LOOP BEGIN at comm_utils.f90(80,11)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at comm_utils.f90(80,11)
   remark #25045: Fused Loops: ( 80 81 )

   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference beam(:,2) has aligned access
   remark #15389: vectorization support: reference PW(:,2) has unaligned access
   remark #15389: vectorization support: reference BEAM_IN(:,2) has unaligned access
   remark #15388: vectorization support: reference beam(:,3) has aligned access   [ comm_utils.f90(81,11) ]
   remark #15389: vectorization support: reference PW(:,2) has unaligned access   [ comm_utils.f90(81,11) ]
   remark #15389: vectorization support: reference BEAM_IN(:,3) has unaligned access   [ comm_utils.f90(81,11) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.406
   remark #15301: FUSED LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 2 
   remark #15450: unmasked unaligned unit stride loads: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 13 
   remark #15477: vector cost: 8.000 
   remark #15478: estimated potential speedup: 1.590 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(81,11)
   remark #25046: Loop lost in Fusion 
LOOP END

LOOP BEGIN at comm_utils.f90(80,11)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at comm_utils.f90(80,11)
<Remainder loop for vectorization>
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(51,66):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_utils.f90(51,57):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_utils.f90(43,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_read_beam_] comm_utils.f90:43

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   26[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm11]
        
    Routine temporaries
        Total         :     505
            Global    :     129
            Local     :     376
        Regenerable   :      54
        Spilled       :      19
        
    Routine stack
        Variables     :   14856 bytes*
            Reads     :      27 [1.72e+01 ~ 0.9%]
            Writes    :      65 [4.70e+01 ~ 2.4%]
        Spills        :     112 bytes*
            Reads     :      27 [1.20e+01 ~ 0.6%]
            Writes    :      19 [9.46e+00 ~ 0.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::COMPUTE_SIGMA_L_MAT

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::COMPUTE_SIGMA_L_MAT) [4/28=14.3%] comm_utils.f90(113,14)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(126,5)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(126,5)
   <Multiversioned v1>
      remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_utils.f90(126,5)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_utils.f90(126,5)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference cl_i(:,:,:) has aligned access
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.833
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 2.550 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at comm_utils.f90(126,5)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at comm_utils.f90(126,5)
   <Multiversioned v2>
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_utils.f90(126,5)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15329: vectorization support: non-unit strided store was emulated for the variable <cl_i(:,:,:)>, stride is unknown to compiler
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15300: LOOP WAS VECTORIZED
         remark #15453: unmasked strided stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 3.000 
         remark #15478: estimated potential speedup: 1.320 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at comm_utils.f90(126,5)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(127,5)
   remark #17109: LOOP WAS AUTO-PARALLELIZED
   remark #17101: parallel loop shared={ } private={ } firstprivate={ k l j sigma m lmax nmaps i } lastprivate={ } firstlastprivate={ } reduction={ }
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(128,8)
      remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
      remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 1 3 2 ) 
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_utils.f90(130,11)
         remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
         remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_utils.f90(132,14)
            remark #15328: vectorization support: non-unit strided load was emulated for the variable <s_i(j,k)>, stride is unknown to compiler   [ comm_utils.f90(133,33) ]
            remark #15328: vectorization support: non-unit strided load was emulated for the variable <s_i(j,i)>, stride is unknown to compiler   [ comm_utils.f90(133,44) ]
            remark #15305: vectorization support: vector length 2
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.404
            remark #15300: LOOP WAS VECTORIZED
            remark #15452: unmasked strided loads: 2 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 9 
            remark #15477: vector cost: 6.500 
            remark #15478: estimated potential speedup: 1.360 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at comm_utils.f90(132,14)
         <Remainder loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(127,5)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(128,8)
      remark #17107: loop was not parallelized: inner loop
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_utils.f90(130,11)
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed ANTI dependence between j (131:14) and j (134:17)
         remark #17106: parallel dependence: assumed FLOW dependence between j (134:17) and j (131:14)
         remark #17106: parallel dependence: assumed FLOW dependence between j (134:17) and j (131:14)
         remark #17106: parallel dependence: assumed ANTI dependence between j (131:14) and j (134:17)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_utils.f90(132,14)
            remark #17107: loop was not parallelized: inner loop
            remark #15328: vectorization support: non-unit strided load was emulated for the variable <s_i(j,k)>, stride is unknown to compiler   [ comm_utils.f90(133,33) ]
            remark #15328: vectorization support: non-unit strided load was emulated for the variable <s_i(j,i)>, stride is unknown to compiler   [ comm_utils.f90(133,44) ]
            remark #15305: vectorization support: vector length 2
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.404
            remark #15300: LOOP WAS VECTORIZED
            remark #15452: unmasked strided loads: 2 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 9 
            remark #15477: vector cost: 6.500 
            remark #15478: estimated potential speedup: 1.360 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at comm_utils.f90(132,14)
         <Remainder loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(113,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_compute_sigma_l_mat_] comm_utils.f90:113

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   26[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm11]
        
    Routine temporaries
        Total         :     412
            Global    :     195
            Local     :     217
        Regenerable   :      62
        Spilled       :     127
        
    Routine stack
        Variables     :     132 bytes*
            Reads     :       2 [1.09e+01 ~ 0.0%]
            Writes    :      25 [0.00e+00 ~ 0.0%]
        Spills        :    1008 bytes*
            Reads     :     170 [7.89e+03 ~ 8.2%]
            Writes    :     144 [3.68e+03 ~ 3.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::INT2STRING

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::INT2STRING) [5/28=17.9%] comm_utils.f90(146,14)
  -> EXTERN: (156,25) __powi4i4
  -> EXTERN: (157,8) for_write_int_fmt
  -> EXTERN: (158,36) __powi4i4


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(155,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #15382: vectorization support: call to function for_write_int_fmt cannot be vectorized   [ comm_utils.f90(157,8) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(146,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_int2string_] comm_utils.f90:146

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   12[ rax rdx rcx rbx rsi rdi r8-r9 r12-r15]
        
    Routine temporaries
        Total         :      37
            Global    :      19
            Local     :      18
        Regenerable   :      12
        Spilled       :       7
        
    Routine stack
        Variables     :      88 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       4 [2.18e+01 ~ 11.4%]
        Spills        :      56 bytes*
            Reads     :       8 [2.12e+01 ~ 11.1%]
            Writes    :       7 [1.13e+01 ~ 5.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::PAD

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::PAD) [6/28=21.4%] comm_utils.f90(164,12)
  -> EXTERN: (164,12) for_len_trim
  -> EXTERN: (171,8) for_len_trim
  -> EXTERN: (172,8) for_cpystr
  -> EXTERN: (175,12) for_len_trim
  -> EXTERN: (176,23) memcpy
  -> EXTERN: (177,8) for_cpystr


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(176,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between b(i-1) (176:23) and b(i-1) (176:23)
   remark #17106: parallel dependence: assumed OUTPUT dependence between b(i-1) (176:23) and b(i-1) (176:23)
   remark #15389: vectorization support: reference b(i-1) has unaligned access   [ comm_utils.f90(176,23) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 16
   remark #15309: vectorization support: normalized vectorization overhead 1.333
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.920 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(176,8)
<Remainder loop for vectorization>
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(164,12):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_pad_] comm_utils.f90:164

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   13[ rax rdx rcx rbx rsi rdi r8-r9 r12-r15 zmm0]
        
    Routine temporaries
        Total         :      57
            Global    :      25
            Local     :      32
        Regenerable   :       3
        Spilled       :       7
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      16 bytes*
            Reads     :       2 [1.00e+00 ~ 1.1%]
            Writes    :       2 [1.50e+00 ~ 1.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::READ_RINGWEIGHTS

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::READ_RINGWEIGHTS) [7/28=25.0%] comm_utils.f90(182,14)
  -> INLINE: (196,10) COMM_UTILS::INT2STRING (isz = 62) (sz = 71)
    -> EXTERN: (156,25) __powi4i4
    -> EXTERN: (157,8) for_write_int_fmt
    -> EXTERN: (158,36) __powi4i4
  -> EXTERN: (197,5) for_concat
  -> EXTERN: (198,13) for_inquire
  -> EXTERN: (201,13) READ_DBINTAB
  -> EXTERN: (205,8) for_write_seq_lis
  -> EXTERN: (206,8) for_write_seq_lis_xmit
  -> EXTERN: (206,8) for_write_seq_lis_xmit
  -> EXTERN: (206,8) for_write_seq_lis
  -> EXTERN: (206,44) for_trim
  -> EXTERN: (207,8) for_write_seq_lis
  -> EXTERN: (208,8) for_write_seq_lis


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(155,5) inlined into comm_utils.f90(222,10)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #15382: vectorization support: call to function for_write_int_fmt cannot be vectorized   [ comm_utils.f90(157,8) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #25436: completely unrolled by 5  
LOOP END

LOOP BEGIN at comm_utils.f90(202,8)
<Multiversioned v1>
   remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(202,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(202,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference weights(:,:) has aligned access
      remark #15388: vectorization support: reference weights(:,:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.500
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 6 
      remark #15477: vector cost: 2.500 
      remark #15478: estimated potential speedup: 2.320 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(202,8)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference weights(:,:) has aligned access
      remark #15388: vectorization support: reference weights(:,:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.111
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(202,8)
<Multiversioned v2>
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(202,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <weights(:,:)>, stride is unknown to compiler
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <weights(:,:)>, stride is unknown to compiler
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.100
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15452: unmasked strided loads: 1 
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 6 
      remark #15477: vector cost: 5.000 
      remark #15478: estimated potential speedup: 1.190 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(202,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(204,8)
<Multiversioned v1>
   remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(204,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(204,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference weights(:,:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.833
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.550 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(204,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(204,8)
<Multiversioned v2>
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(204,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <weights(:,:)>, stride is unknown to compiler
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15300: LOOP WAS VECTORIZED
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 1.320 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(204,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(182,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_read_ringweights_] comm_utils.f90:182

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :     280
            Global    :      81
            Local     :     199
        Regenerable   :     122
        Spilled       :      15
        
    Routine stack
        Variables     :     605 bytes*
            Reads     :       1 [1.00e+00 ~ 0.1%]
            Writes    :      49 [4.32e+01 ~ 4.5%]
        Spills        :      80 bytes*
            Reads     :      10 [1.22e+01 ~ 1.3%]
            Writes    :      10 [5.22e+00 ~ 0.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::READ_PIXWIN

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::READ_PIXWIN) [8/28=28.6%] comm_utils.f90(213,14)
  -> EXTERN: (225,5) for_allocate
  -> EXTERN: (225,5) for_check_mult_overflow64
  -> INLINE: (233,10) COMM_UTILS::INT2STRING (isz = 62) (sz = 71)
    -> EXTERN: (156,25) __powi4i4
    -> EXTERN: (157,8) for_write_int_fmt
    -> EXTERN: (158,36) __powi4i4
  -> EXTERN: (234,5) for_concat
  -> EXTERN: (235,13) for_inquire
  -> EXTERN: (238,13) READ_DBINTAB
  -> EXTERN: (242,8) for_write_seq_lis
  -> EXTERN: (243,8) for_write_seq_lis_xmit
  -> EXTERN: (243,8) for_write_seq_lis_xmit
  -> EXTERN: (243,8) for_write_seq_lis
  -> EXTERN: (243,50) for_trim
  -> EXTERN: (244,8) for_write_seq_lis
  -> EXTERN: (245,8) for_write_seq_lis


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(155,5) inlined into comm_utils.f90(259,10)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #15382: vectorization support: call to function for_write_int_fmt cannot be vectorized   [ comm_utils.f90(157,8) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (157:8) and at (157:8)
   remark #25436: completely unrolled by 4  
LOOP END

LOOP BEGIN at comm_utils.f90(239,24)
<Peeled loop for vectorization, Multiversioned v1>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at comm_utils.f90(239,24)
<Multiversioned v1>
   remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference pixwin(:,3) has aligned access
   remark #15388: vectorization support: reference pixwin(:,2) has aligned access
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 4.667
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 1.500 
   remark #15478: estimated potential speedup: 2.550 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(239,24)
<Alternate Alignment Vectorized Loop, Multiversioned v1>
LOOP END

LOOP BEGIN at comm_utils.f90(239,24)
<Remainder loop for vectorization, Multiversioned v1>
LOOP END

LOOP BEGIN at comm_utils.f90(239,24)
<Multiversioned v2>
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <pixwin(:,3)>, stride is unknown to compiler
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <pixwin(:,2)>, stride is unknown to compiler
   remark #15305: vectorization support: vector length 2
   remark #15452: unmasked strided loads: 1 
   remark #15453: unmasked strided stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 1.000 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at comm_utils.f90(239,24)
<Remainder, Multiversioned v2>
LOOP END

LOOP BEGIN at comm_utils.f90(241,8)
<Multiversioned v1>
   remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(241,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(241,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference pixwin(:,:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.833
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.550 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(241,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(241,8)
<Multiversioned v2>
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(241,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <pixwin(:,:)>, stride is unknown to compiler
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15300: LOOP WAS VECTORIZED
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 1.320 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(241,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(213,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_read_pixwin_] comm_utils.f90:213

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :     326
            Global    :      89
            Local     :     237
        Regenerable   :     123
        Spilled       :      12
        
    Routine stack
        Variables     :     708 bytes*
            Reads     :       3 [2.40e+00 ~ 0.4%]
            Writes    :      56 [4.61e+01 ~ 7.4%]
        Spills        :      56 bytes*
            Reads     :       7 [8.80e+00 ~ 1.4%]
            Writes    :       7 [4.78e+00 ~ 0.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::IS_NAN

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::IS_NAN) [9/28=32.1%] comm_utils.f90(294,12)


    Report from: Code generation optimizations [cg]

comm_utils.f90(294,12):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_is_nan_] comm_utils.f90:294

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rdi zmm0-zmm2]
        
    Routine temporaries
        Total         :      18
            Global    :       0
            Local     :      18
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::CL2S

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::CL2S) [10/28=35.7%] comm_utils.f90(301,14)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(311,5)
<Multiversioned v1>
   remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(311,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(311,5)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference s(:,:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.833
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.550 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(311,5)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(311,5)
<Multiversioned v2>
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(311,5)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <s(:,:)>, stride is unknown to compiler
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15300: LOOP WAS VECTORIZED
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 1.320 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(311,5)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(313,5)
<Multiversioned v1>
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between k (314:8) and k (317:11)
   remark #17106: parallel dependence: assumed FLOW dependence between k (317:11) and k (314:8)
   remark #17106: parallel dependence: assumed FLOW dependence between k (317:11) and k (314:8)
   remark #17106: parallel dependence: assumed ANTI dependence between k (314:8) and k (317:11)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(314,8)
   <Peeled loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(314,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25427: Loop Statements Reordered
      remark #15388: vectorization support: reference cl(k) has aligned access   [ comm_utils.f90(315,11) ]
      remark #15388: vectorization support: reference s(j,i) has aligned access   [ comm_utils.f90(316,11) ]
      remark #15388: vectorization support: reference cl(k) has aligned access   [ comm_utils.f90(316,11) ]
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <s(i,j)>, stride is unknown to compiler   [ comm_utils.f90(315,11) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.500
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 5.000 
      remark #15478: estimated potential speedup: 1.750 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(314,8)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at comm_utils.f90(314,8)
   <Remainder loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(313,5)
<Multiversioned v2>
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between k (314:8) and k (317:11)
   remark #17106: parallel dependence: assumed FLOW dependence between k (317:11) and k (314:8)
   remark #17106: parallel dependence: assumed FLOW dependence between k (317:11) and k (314:8)
   remark #17106: parallel dependence: assumed ANTI dependence between k (314:8) and k (317:11)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(314,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25427: Loop Statements Reordered
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <s(i,j)>, stride is unknown to compiler   [ comm_utils.f90(315,11) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <cl(k)>, stride is unknown to compiler   [ comm_utils.f90(315,11) ]
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <s(j,i)>, stride is unknown to compiler   [ comm_utils.f90(316,11) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <cl(k)>, stride is unknown to compiler   [ comm_utils.f90(316,11) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.147
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15452: unmasked strided loads: 2 
      remark #15453: unmasked strided stores: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 8.500 
      remark #15478: estimated potential speedup: 1.050 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(314,8)
   <Remainder loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(301,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_cl2s_] comm_utils.f90:301

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   18[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm3]
        
    Routine temporaries
        Total         :     226
            Global    :     105
            Local     :     121
        Regenerable   :       5
        Spilled       :      49
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     336 bytes*
            Reads     :      63 [2.00e+02 ~ 7.0%]
            Writes    :      52 [6.93e+01 ~ 2.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::S2CL

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::S2CL) [11/28=39.3%] comm_utils.f90(323,14)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(334,5)
<Multiversioned v1>
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
   remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between cl(k) (336:11) and cl(k) (336:11)
   remark #17106: parallel dependence: assumed OUTPUT dependence between cl(k) (336:11) and cl(k) (336:11)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(335,8)
   <Peeled loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(335,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference cl(k) has aligned access   [ comm_utils.f90(336,11) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <s(i,j)>, stride is unknown to compiler   [ comm_utils.f90(336,11) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.500
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 5 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 1.630 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(335,8)
   <Remainder loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(334,5)
<Multiversioned v2>
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between cl(k) (336:11) and cl(k) (336:11)
   remark #17106: parallel dependence: assumed OUTPUT dependence between cl(k) (336:11) and cl(k) (336:11)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(335,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <cl(k)>, stride is unknown to compiler   [ comm_utils.f90(336,11) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <s(i,j)>, stride is unknown to compiler   [ comm_utils.f90(336,11) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.056
      remark #15300: LOOP WAS VECTORIZED
      remark #15452: unmasked strided loads: 1 
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 5 
      remark #15477: vector cost: 4.500 
      remark #15478: estimated potential speedup: 1.100 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(335,8)
   <Remainder loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(323,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_s2cl_] comm_utils.f90:323

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   18[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm3]
        
    Routine temporaries
        Total         :     154
            Global    :      69
            Local     :      85
        Regenerable   :       4
        Spilled       :      28
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     208 bytes*
            Reads     :      43 [9.52e+01 ~ 6.5%]
            Writes    :      35 [4.06e+01 ~ 2.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::MKDIR

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::MKDIR) [12/28=42.9%] comm_utils.f90(370,14)
  -> EXTERN: (375,13) is_dir_
  -> EXTERN: (377,8) __resetsp_inlined
  -> EXTERN: (377,8) mkdir_c_
  -> EXTERN: (377,8) __getsp_inlined
  -> EXTERN: (377,16) for_trim
  -> EXTERN: (377,21) _alloca
  -> EXTERN: (379,13) FSLEEP
  -> EXTERN: (380,11) is_dir_
  -> EXTERN: (381,11) __getsp_inlined
  -> EXTERN: (381,11) mkdir_c_
  -> EXTERN: (381,11) __resetsp_inlined
  -> EXTERN: (381,19) for_trim
  -> EXTERN: (381,24) _alloca
  -> EXTERN: (383,5) for_write_seq_lis
  -> EXTERN: (383,5) __resetsp_inlined
  -> EXTERN: (383,5) __getsp_inlined
  -> EXTERN: (383,47) _alloca
  -> EXTERN: (383,47) for_concat
  -> EXTERN: (383,50) for_trim
  -> EXTERN: (383,55) _alloca


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]



Non-optimizable loops:


LOOP BEGIN at comm_utils.f90(382,5)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(370,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_mkdir_] comm_utils.f90:370

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rsi rdi r8 r12-r15]
        
    Routine temporaries
        Total         :      88
            Global    :      36
            Local     :      52
        Regenerable   :      19
        Spilled       :       5
        
    Routine stack
        Variables     :     112 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       7 [1.58e-01 ~ 0.3%]
        Spills        :       8 bytes*
            Reads     :       3 [2.77e-01 ~ 0.5%]
            Writes    :       1 [2.77e-01 ~ 0.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::MKDIRS

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::MKDIRS) [13/28=46.4%] comm_utils.f90(386,14)
  -> EXTERN: (391,9) for_len_trim
  -> INLINE: (405,13) COMM_UTILS::MKDIR (isz = 144) (sz = 151)
    -> EXTERN: (375,13) is_dir_
    -> EXTERN: (377,8) __getsp_inlined
    -> EXTERN: (377,8) mkdir_c_
    -> EXTERN: (377,8) __resetsp_inlined
    -> EXTERN: (377,16) for_trim
    -> EXTERN: (377,21) _alloca
    -> EXTERN: (379,13) FSLEEP
    -> EXTERN: (380,11) is_dir_
    -> EXTERN: (381,11) __resetsp_inlined
    -> EXTERN: (381,11) mkdir_c_
    -> EXTERN: (381,11) __getsp_inlined
    -> EXTERN: (381,19) for_trim
    -> EXTERN: (381,24) _alloca
    -> EXTERN: (383,5) __getsp_inlined
    -> EXTERN: (383,5) __resetsp_inlined
    -> EXTERN: (383,5) for_write_seq_lis
    -> EXTERN: (383,47) for_concat
    -> EXTERN: (383,47) _alloca
    -> EXTERN: (383,50) for_trim
    -> EXTERN: (383,55) _alloca


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(393,8)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable n was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at comm_utils.f90(402,8)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable j was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at comm_utils.f90(404,8)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable j was found, but loop iteration count cannot be computed before executing the loop
LOOP END


Non-optimizable loops:


LOOP BEGIN at comm_utils.f90(406,13)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ comm_utils.f90(382,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at comm_utils.f90(382,5) inlined into comm_utils.f90(431,13)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(386,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_mkdirs_] comm_utils.f90:386

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   13[ rax rdx rcx rbx rsi rdi r8-r10 r12-r15]
        
    Routine temporaries
        Total         :     110
            Global    :      51
            Local     :      59
        Regenerable   :      20
        Spilled       :      11
        
    Routine stack
        Variables     :     112 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       7 [3.10e-01 ~ 0.1%]
        Spills        :      72 bytes*
            Reads     :      17 [9.93e+00 ~ 4.2%]
            Writes    :      11 [7.43e+00 ~ 3.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::MV

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::MV) [14/28=50.0%] comm_utils.f90(410,14)
  -> EXTERN: (413,5) __resetsp_inlined
  -> EXTERN: (413,5) __getsp_inlined
  -> EXTERN: (413,19) mv_c_
  -> EXTERN: (413,24) for_trim
  -> EXTERN: (413,29) _alloca
  -> EXTERN: (413,36) for_trim
  -> EXTERN: (413,41) _alloca
  -> EXTERN: (414,15) for_write_seq_lis
  -> EXTERN: (414,15) __resetsp_inlined
  -> EXTERN: (414,15) __getsp_inlined
  -> EXTERN: (414,48) for_trim
  -> EXTERN: (414,53) _alloca
  -> EXTERN: (414,74) for_trim
  -> EXTERN: (414,79) _alloca
  -> EXTERN: (414,83) _alloca
  -> EXTERN: (414,83) for_concat


    Report from: Code generation optimizations [cg]

comm_utils.f90(410,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_mv_] comm_utils.f90:410

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rsi rdi r8 r12-r15]
        
    Routine temporaries
        Total         :      85
            Global    :      34
            Local     :      51
        Regenerable   :      14
        Spilled       :       9
        
    Routine stack
        Variables     :     160 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :      13 [5.20e+00 ~ 6.4%]
        Spills        :      32 bytes*
            Reads     :       4 [3.40e+00 ~ 4.2%]
            Writes    :       4 [3.40e+00 ~ 4.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::RM

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::RM) [15/28=53.6%] comm_utils.f90(417,14)
  -> EXTERN: (422,5) __resetsp_inlined
  -> EXTERN: (422,5) __getsp_inlined
  -> EXTERN: (422,19) rm_c_
  -> EXTERN: (422,24) for_trim
  -> EXTERN: (422,29) _alloca
  -> EXTERN: (423,27) __getsp_inlined
  -> EXTERN: (423,27) for_write_seq_lis
  -> EXTERN: (423,27) __resetsp_inlined
  -> EXTERN: (423,62) for_trim
  -> EXTERN: (423,67) _alloca
  -> EXTERN: (423,73) _alloca
  -> EXTERN: (423,73) for_concat


    Report from: Code generation optimizations [cg]

comm_utils.f90(417,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_rm_] comm_utils.f90:417

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rsi rdi r8 r12-r15]
        
    Routine temporaries
        Total         :      63
            Global    :      25
            Local     :      38
        Regenerable   :      14
        Spilled       :       5
        
    Routine stack
        Variables     :     128 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       9 [1.44e+00 ~ 2.6%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::TOUCH

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::TOUCH) [16/28=57.1%] comm_utils.f90(426,14)
  -> INLINE: (429,12) COMM_UTILS::GETLUN (isz = 42) (sz = 45)
    -> EXTERN: (35,16) for_inquire
    -> EXTERN: (37,19) for_inquire
  -> EXTERN: (430,5) for_open
  -> EXTERN: (431,11) for_close


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(32,5) inlined into comm_utils.f90(455,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(426,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_touch_] comm_utils.f90:426

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rsi rdi r8 r12-r15]
        
    Routine temporaries
        Total         :      47
            Global    :      18
            Local     :      29
        Regenerable   :      32
        Spilled       :       5
        
    Routine stack
        Variables     :     176 bytes*
            Reads     :       2 [3.64e+01 ~ 7.6%]
            Writes    :       9 [7.78e+01 ~ 16.2%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::ALLOCATE_MAP

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::ALLOCATE_MAP) [17/28=60.7%] comm_utils.f90(449,14)
  -> EXTERN: (449,50) for_deallocate
  -> EXTERN: (449,59) for_deallocate
  -> EXTERN: (449,66) for_deallocate
  -> EXTERN: (461,5) for_alloc_allocatable
  -> EXTERN: (461,5) for_check_mult_overflow64
  -> INLINE: (463,13) COMM_UTILS::READ_MAP (isz = 161) (sz = 170)
    -> EXTERN: (501,13) f_lanint_val
    -> EXTERN: (503,14) GETSIZE_FITS
    -> EXTERN: (503,27) for_trim
    -> EXTERN: (505,8) for_write_seq_lis_xmit
    -> EXTERN: (505,8) for_write_seq_lis
    -> EXTERN: (505,64) for_trim
    -> EXTERN: (508,10) INPUT_MAP4_D
    -> EXTERN: (511,16) CONVERT_NEST2RING_DOUBLE_1D
  -> EXTERN: (469,30) for_dealloc_allocatable
  -> EXTERN: (470,8) for_check_mult_overflow64
  -> EXTERN: (470,8) for_alloc_allocatable
  -> EXTERN: (477,31) for_dealloc_allocatable
  -> EXTERN: (478,8) for_check_mult_overflow64
  -> EXTERN: (478,8) for_alloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(510,8) inlined into comm_utils.f90(489,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (511:16) and MAP (511:16)
   remark #17106: parallel dependence: assumed OUTPUT dependence between MAP (511:16) and at (511:16)
   remark #15382: vectorization support: call to function CONVERT_NEST2RING_DOUBLE_1D cannot be vectorized   [ comm_utils.f90(511,16) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (511:16) and MAP (511:16)
   remark #15346: vector dependence: assumed OUTPUT dependence between MAP (511:16) and at (511:16)
LOOP END

LOOP BEGIN at comm_utils.f90(465,8)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(465,8)
      remark #25408: memset generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between map(:,:) (465:8) and map(:,:) (465:8)
      remark #17106: parallel dependence: assumed OUTPUT dependence between map(:,:) (465:8) and map(:,:) (465:8)
      remark #15542: loop was not vectorized: inner loop was already vectorized
      remark #25015: Estimate of max trip count of loop=1

      LOOP BEGIN at comm_utils.f90(465,8)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15389: vectorization support: reference map(:,:) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 1.450 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at comm_utils.f90(465,8)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(471,8)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at comm_utils.f90(471,8)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference rings(i) has aligned access   [ comm_utils.f90(472,11) ]
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 3.667
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.750 
   remark #15478: estimated potential speedup: 2.480 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(471,8)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at comm_utils.f90(479,8)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at comm_utils.f90(479,8)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference pixels(i+1) has aligned access   [ comm_utils.f90(480,11) ]
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 3.667
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.750 
   remark #15478: estimated potential speedup: 2.480 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(479,8)
<Remainder loop for vectorization>
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(465,8):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_utils.f90(465,8):remark #34026: call to memset implemented as a call to optimized library version
comm_utils.f90(449,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_allocate_map_] comm_utils.f90:449

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   23[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm8]
        
    Routine temporaries
        Total         :     415
            Global    :      80
            Local     :     335
        Regenerable   :      85
        Spilled       :      16
        
    Routine stack
        Variables     :     472 bytes*
            Reads     :       9 [3.46e+00 ~ 0.6%]
            Writes    :      16 [5.49e+00 ~ 1.0%]
        Spills        :      88 bytes*
            Reads     :      19 [7.65e+00 ~ 1.4%]
            Writes    :      14 [6.70e+00 ~ 1.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::READ_MAP

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::READ_MAP) [18/28=64.3%] comm_utils.f90(490,14)
  -> EXTERN: (501,13) f_lanint_val
  -> EXTERN: (503,14) GETSIZE_FITS
  -> EXTERN: (503,27) for_trim
  -> EXTERN: (505,8) for_write_seq_lis
  -> EXTERN: (505,8) for_write_seq_lis_xmit
  -> EXTERN: (505,64) for_trim
  -> EXTERN: (508,10) INPUT_MAP4_D
  -> EXTERN: (511,16) CONVERT_NEST2RING_DOUBLE_1D


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(510,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (511:16) and map (511:16)
   remark #17106: parallel dependence: assumed OUTPUT dependence between map (511:16) and at (511:16)
   remark #15382: vectorization support: call to function CONVERT_NEST2RING_DOUBLE_1D cannot be vectorized   [ comm_utils.f90(511,16) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (511:16) and map (511:16)
   remark #15346: vector dependence: assumed OUTPUT dependence between map (511:16) and at (511:16)
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(490,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_read_map_] comm_utils.f90:490

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   22[ rax rdx rcx rbx rsi rdi r8-r10 r12-r15 zmm0-zmm8]
        
    Routine temporaries
        Total         :     102
            Global    :      22
            Local     :      80
        Regenerable   :      47
        Spilled       :       5
        
    Routine stack
        Variables     :     448 bytes*
            Reads     :       6 [4.16e+00 ~ 2.9%]
            Writes    :      16 [1.37e+01 ~ 9.4%]
        Spills        :      16 bytes*
            Reads     :       2 [3.13e-01 ~ 0.2%]
            Writes    :       2 [3.13e-01 ~ 0.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::TSUM

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::TSUM) [19/28=67.9%] comm_utils.f90(541,12)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(550,5)
<Peeled loop for vectorization, Multiversioned v1>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at comm_utils.f90(550,5)
<Multiversioned v1>
   remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference y(i) has aligned access   [ comm_utils.f90(551,31) ]
   remark #15389: vectorization support: reference y(i+1) has unaligned access   [ comm_utils.f90(551,36) ]
   remark #15388: vectorization support: reference x(i+1) has aligned access   [ comm_utils.f90(551,47) ]
   remark #15389: vectorization support: reference x(i) has unaligned access   [ comm_utils.f90(551,54) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.485
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 2 
   remark #15450: unmasked unaligned unit stride loads: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 16 
   remark #15477: vector cost: 8.500 
   remark #15478: estimated potential speedup: 1.830 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(550,5)
<Alternate Alignment Vectorized Loop, Multiversioned v1>
LOOP END

LOOP BEGIN at comm_utils.f90(550,5)
<Remainder loop for vectorization, Multiversioned v1>
   remark #15389: vectorization support: reference y(i) has unaligned access   [ comm_utils.f90(551,31) ]
   remark #15389: vectorization support: reference y(i+1) has unaligned access   [ comm_utils.f90(551,36) ]
   remark #15388: vectorization support: reference x(i+1) has aligned access   [ comm_utils.f90(551,47) ]
   remark #15389: vectorization support: reference x(i) has unaligned access   [ comm_utils.f90(551,54) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 1.346
LOOP END

LOOP BEGIN at comm_utils.f90(550,5)
<Multiversioned v2>
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <y(i)>, stride is unknown to compiler   [ comm_utils.f90(551,31) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <y(i+1)>, stride is unknown to compiler   [ comm_utils.f90(551,36) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <x(i+1)>, stride is unknown to compiler   [ comm_utils.f90(551,47) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <x(i)>, stride is unknown to compiler   [ comm_utils.f90(551,54) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.207
   remark #15300: LOOP WAS VECTORIZED
   remark #15452: unmasked strided loads: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 16 
   remark #15477: vector cost: 11.500 
   remark #15478: estimated potential speedup: 1.370 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(550,5)
<Remainder loop for vectorization, Multiversioned v2>
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(551,31):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,31):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,31):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,31):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,31):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,31):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,31):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,31):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(551,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
comm_utils.f90(541,12):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_tsum_] comm_utils.f90:541

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   26[ rax rdx rcx rsi rdi r8-r12 zmm0-zmm15]
        
    Routine temporaries
        Total         :     244
            Global    :      41
            Local     :     203
        Regenerable   :       7
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::MPI_DOT_PRODUCT

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::MPI_DOT_PRODUCT) [20/28=71.4%] comm_utils.f90(572,12)
  -> EXTERN: (583,10) mpi_allreduce_


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(582,12)
<Peeled loop for vectorization, Multiversioned v1>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at comm_utils.f90(582,12)
<Multiversioned v1>
   remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference x(:) has aligned access
   remark #15388: vectorization support: reference y(:) has aligned access
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 1.031
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 1.920 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(582,12)
<Alternate Alignment Vectorized Loop, Multiversioned v1>
LOOP END

LOOP BEGIN at comm_utils.f90(582,12)
<Remainder loop for vectorization, Multiversioned v1>
LOOP END

LOOP BEGIN at comm_utils.f90(582,12)
<Multiversioned v2>
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <x(:)>, stride is unknown to compiler
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <y(:)>, stride is unknown to compiler
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.396
   remark #15300: LOOP WAS VECTORIZED
   remark #15452: unmasked strided loads: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 6.000 
   remark #15478: estimated potential speedup: 1.310 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(582,12)
<Remainder loop for vectorization, Multiversioned v2>
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(572,12):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_mpi_dot_product_] comm_utils.f90:572

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   22[ rax rdx rcx rsi rdi r8-r12 zmm0-zmm11]
        
    Routine temporaries
        Total         :     124
            Global    :      30
            Local     :      94
        Regenerable   :      13
        Spilled       :       1
        
    Routine stack
        Variables     :      12 bytes*
            Reads     :       1 [1.00e+00 ~ 0.3%]
            Writes    :       1 [1.00e+00 ~ 0.3%]
        Spills        :       8 bytes*
            Reads     :       1 [4.50e-01 ~ 0.1%]
            Writes    :       1 [4.50e-01 ~ 0.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::READ_SPECTRUM

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::READ_SPECTRUM) [21/28=75.0%] comm_utils.f90(591,14)
  -> INLINE: (601,12) COMM_UTILS::GETLUN (isz = 42) (sz = 45)
    -> EXTERN: (35,16) for_inquire
    -> EXTERN: (37,19) for_inquire
  -> EXTERN: (602,5) __resetsp_inlined
  -> EXTERN: (602,5) for_open
  -> EXTERN: (602,5) __getsp_inlined
  -> EXTERN: (602,21) for_trim
  -> EXTERN: (602,26) _alloca
  -> EXTERN: (607,8) for_read_seq_lis
  -> EXTERN: (611,18) for_backspace
  -> EXTERN: (612,8) for_read_seq_lis_xmit
  -> EXTERN: (612,8) for_read_seq_lis
  -> EXTERN: (615,11) for_close
  -> EXTERN: (618,8) __resetsp_inlined
  -> EXTERN: (618,8) for_write_seq_lis_xmit
  -> EXTERN: (618,8) for_write_seq_lis
  -> EXTERN: (618,8) __getsp_inlined
  -> EXTERN: (618,62) for_trim
  -> EXTERN: (618,67) _alloca
  -> EXTERN: (619,8) for_stop_core
  -> EXTERN: (622,5) for_check_mult_overflow64
  -> EXTERN: (622,5) for_alloc_allocatable
  -> EXTERN: (624,5) __getsp_inlined
  -> EXTERN: (624,5) for_open
  -> EXTERN: (624,5) __resetsp_inlined
  -> EXTERN: (624,21) for_trim
  -> EXTERN: (624,26) _alloca
  -> EXTERN: (626,8) for_read_seq_lis
  -> EXTERN: (630,18) for_backspace
  -> EXTERN: (631,8) for_read_seq_lis_xmit
  -> EXTERN: (631,8) for_read_seq_lis
  -> EXTERN: (634,8) for_read_int_lis
  -> EXTERN: (635,8) for_read_int_lis
  -> EXTERN: (639,14) __resetsp_inlined
  -> EXTERN: (639,14) for_write_seq_lis_xmit
  -> EXTERN: (639,14) for_write_seq_lis_xmit
  -> EXTERN: (639,14) for_write_seq_lis_xmit
  -> EXTERN: (639,14) for_write_seq_lis_xmit
  -> EXTERN: (639,14) for_write_seq_lis_xmit
  -> EXTERN: (639,14) for_write_seq_lis
  -> EXTERN: (639,14) __getsp_inlined
  -> EXTERN: (639,50) for_trim
  -> EXTERN: (639,55) _alloca
  -> EXTERN: (640,14) for_stop_core
  -> EXTERN: (645,11) for_close


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(32,5) inlined into comm_utils.f90(627,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at comm_utils.f90(605,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at comm_utils.f90(624,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at comm_utils.f90(638,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (639:14) and at (639:14)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (639:14) and at (639:14)
      remark #15382: vectorization support: call to function for_write_seq_lis cannot be vectorized   [ comm_utils.f90(639,14) ]
      remark #15382: vectorization support: call to function for_trim cannot be vectorized   [ comm_utils.f90(639,50) ]
      remark #15382: vectorization support: call to function for_write_seq_lis_xmit cannot be vectorized   [ comm_utils.f90(639,14) ]
      remark #15382: vectorization support: call to function for_write_seq_lis_xmit cannot be vectorized   [ comm_utils.f90(639,14) ]
      remark #15382: vectorization support: call to function for_write_seq_lis_xmit cannot be vectorized   [ comm_utils.f90(639,14) ]
      remark #15382: vectorization support: call to function for_write_seq_lis_xmit cannot be vectorized   [ comm_utils.f90(639,14) ]
      remark #15382: vectorization support: call to function for_write_seq_lis_xmit cannot be vectorized   [ comm_utils.f90(639,14) ]
      remark #15382: vectorization support: call to function for_stop_core cannot be vectorized   [ comm_utils.f90(640,14) ]
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (639:14) and at (639:14)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (639:14) and at (639:14)
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(648,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at comm_utils.f90(648,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference spectrum(:,1) has aligned access
   remark #15388: vectorization support: reference spectrum(:,1) has aligned access
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.417
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 6 
   remark #15477: vector cost: 3.000 
   remark #15478: estimated potential speedup: 1.950 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(648,5)
<Remainder loop for vectorization>
LOOP END


Non-optimizable loops:


LOOP BEGIN at comm_utils.f90(631,8)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(591,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_read_spectrum_] comm_utils.f90:591

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   19[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :     391
            Global    :      95
            Local     :     296
        Regenerable   :     186
        Spilled       :      16
        
    Routine stack
        Variables     :     864 bytes*
            Reads     :       5 [6.67e+01 ~ 1.6%]
            Writes    :      58 [4.44e+02 ~ 10.7%]
        Spills        :      88 bytes*
            Reads     :      24 [2.61e+02 ~ 6.3%]
            Writes    :      14 [7.91e+01 ~ 1.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::READ_INSTRUMENT_FILE

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::READ_INSTRUMENT_FILE) [22/28=78.6%] comm_utils.f90(652,14)
  -> EXTERN: (665,13) __resetsp_inlined
  -> EXTERN: (665,13) for_inquire
  -> EXTERN: (665,13) __getsp_inlined
  -> EXTERN: (665,18) for_trim
  -> EXTERN: (665,23) _alloca
  -> INLINE: (667,15) COMM_UTILS::GETLUN (isz = 42) (sz = 45)
    -> EXTERN: (35,16) for_inquire
    -> EXTERN: (37,19) for_inquire
  -> EXTERN: (668,8) __getsp_inlined
  -> EXTERN: (668,8) for_open
  -> EXTERN: (668,8) __resetsp_inlined
  -> EXTERN: (668,24) for_trim
  -> EXTERN: (668,29) _alloca
  -> EXTERN: (670,11) for_read_seq_fmt
  -> EXTERN: (671,11) for_cpystr
  -> EXTERN: (671,18) for_trim
  -> EXTERN: (671,23) for_adjustl
  -> EXTERN: (673,11) for_read_int_lis_xmit
  -> EXTERN: (673,11) for_read_int_lis
  -> EXTERN: (674,15) for_trim
  -> EXTERN: (674,26) __getsp_inlined
  -> EXTERN: (674,26) __resetsp_inlined
  -> EXTERN: (674,26) for_cpstr
  -> EXTERN: (674,29) for_trim
  -> EXTERN: (674,34) _alloca
  -> EXTERN: (675,18) for_trim
  -> EXTERN: (675,23) _alloca
  -> EXTERN: (675,30) __resetsp_inlined
  -> EXTERN: (675,30) for_cpstr
  -> EXTERN: (675,30) __getsp_inlined
  -> EXTERN: (677,23) for_trim
  -> EXTERN: (677,28) _alloca
  -> EXTERN: (677,35) __resetsp_inlined
  -> EXTERN: (677,35) for_cpstr
  -> EXTERN: (677,35) __getsp_inlined
  -> EXTERN: (680,22) __resetsp_inlined
  -> INLINE: (680,22) COMM_UTILS::REPORT_ERROR (isz = 53) (sz = 60)
    -> EXTERN: (564,10) mpi_comm_rank_
    -> EXTERN: (566,20) __getsp_inlined
    -> EXTERN: (566,20) __resetsp_inlined
    -> EXTERN: (566,20) for_write_seq_lis
    -> EXTERN: (566,31) for_trim
    -> EXTERN: (566,36) _alloca
    -> EXTERN: (567,10) mpi_finalize_
    -> EXTERN: (568,5) for_stop_core
  -> EXTERN: (680,22) __getsp_inlined
  -> EXTERN: (680,68) for_concat
  -> EXTERN: (680,68) _alloca
  -> EXTERN: (680,70) for_trim
  -> EXTERN: (680,75) _alloca
  -> EXTERN: (685,14) for_close


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(32,5) inlined into comm_utils.f90(693,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at comm_utils.f90(668,8)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(652,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_read_instrument_file_] comm_utils.f90:652

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   13[ rax rdx rcx rbx rsi rdi r8-r10 r12-r15]
        
    Routine temporaries
        Total         :     269
            Global    :      84
            Local     :     185
        Regenerable   :     137
        Spilled       :      12
        
    Routine stack
        Variables     :    4508 bytes*
            Reads     :       7 [7.26e+00 ~ 4.5%]
            Writes    :      31 [1.98e+01 ~ 12.2%]
        Spills        :      56 bytes*
            Reads     :       9 [6.46e-01 ~ 0.4%]
            Writes    :       7 [2.48e+00 ~ 1.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::ASSERT

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::ASSERT) [23/28=82.1%] comm_utils.f90(690,14)
  -> EXTERN: (695,5) for_write_seq_fmt
  -> EXTERN: (696,5) for_stop_core


    Report from: Code generation optimizations [cg]

comm_utils.f90(690,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_assert_] comm_utils.f90:690

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rsi rdi r8-r9]
        
    Routine temporaries
        Total         :      31
            Global    :       9
            Local     :      22
        Regenerable   :      19
        Spilled       :       0
        
    Routine stack
        Variables     :      80 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       3 [2.20e-01 ~ 1.3%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::COMPUTE_RADIAL_BEAM

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::COMPUTE_RADIAL_BEAM) [24/28=85.7%] comm_utils.f90(700,14)
  -> EXTERN: (700,45) for_dealloc_all_nopdtlen
  -> INLINE: (719,23) COMM_UTILS::REPORT_ERROR (isz = 53) (sz = 60)
    -> EXTERN: (564,10) mpi_comm_rank_
    -> EXTERN: (566,20) __getsp_inlined
    -> EXTERN: (566,20) __resetsp_inlined
    -> EXTERN: (566,20) for_write_seq_lis
    -> EXTERN: (566,31) for_trim
    -> EXTERN: (566,36) _alloca
    -> EXTERN: (567,10) mpi_finalize_
    -> EXTERN: (568,5) for_stop_core
  -> EXTERN: (724,5) for_alloc_allocatable
  -> EXTERN: (724,5) for_check_mult_overflow64
  -> EXTERN: (724,5) for_alloc_allocatable
  -> EXTERN: (724,5) for_check_mult_overflow64
  -> EXTERN: (724,5) for_alloc_allocatable
  -> EXTERN: (724,5) for_check_mult_overflow64
  -> EXTERN: (727,13) COMP_NORMALISED_PLM
  -> EXTERN: (737,5) for_alloc_allocatable
  -> EXTERN: (737,5) for_check_mult_overflow64
  -> EXTERN: (744,13) SPLINE_SIMPLE
  -> EXTERN: (747,5) for_dealloc_allocatable
  -> EXTERN: (747,5) for_dealloc_allocatable
  -> EXTERN: (747,5) for_dealloc_allocatable
  -> EXTERN: (749,3) for_dealloc_allocatable
  -> EXTERN: (749,3) for_dealloc_allocatable
  -> EXTERN: (749,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(717,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable l was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at comm_utils.f90(725,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between X(i) (726:8) and X(i) (727:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between X(i) (727:13) and X(i) (726:8)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(728,8)
   <Distributed chunk1>
      remark #25426: Loop Distributed (2 way) 
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <Y(i,j)>, stride is unknown to compiler   [ comm_utils.f90(729,11) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15301: PARTIAL LOOP WAS VECTORIZED
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 1.320 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(728,8)
   <Remainder loop for vectorization, Distributed chunk1>
   LOOP END

   LOOP BEGIN at comm_utils.f90(728,8)
   <Multiversioned v1, Distributed chunk2>
      remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
      remark #17100: DISTRIBUTED LOOP WAS AUTO-PARALLELIZED
      remark #17101: parallel loop shared={ } private={ } firstprivate={ l j lmax PL Y i } lastprivate={ } firstlastprivate={ } reduction={ }
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_utils.f90(730,11)
         remark #15389: vectorization support: reference bl(l,j) has unaligned access   [ comm_utils.f90(731,32) ]
         remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.013
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 80 
         remark #15477: vector cost: 38.000 
         remark #15478: estimated potential speedup: 2.070 
         remark #15486: divides: 1 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at comm_utils.f90(730,11)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference bl(l,j) has unaligned access   [ comm_utils.f90(731,32) ]
         remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 0.175
         remark #15301: REMAINDER LOOP WAS VECTORIZED
      LOOP END

      LOOP BEGIN at comm_utils.f90(730,11)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at comm_utils.f90(728,8)
   <Multiversioned v2, Distributed chunk2>
      remark #17100: DISTRIBUTED LOOP WAS AUTO-PARALLELIZED
      remark #17101: parallel loop shared={ } private={ } firstprivate={ l Y PL lmax j i } lastprivate={ } firstlastprivate={ } reduction={ }
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_utils.f90(730,11)
         remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <bl(l,j)>, stride is unknown to compiler   [ comm_utils.f90(731,32) ]
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.003
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 80 
         remark #15477: vector cost: 38.500 
         remark #15478: estimated potential speedup: 2.040 
         remark #15486: divides: 1 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at comm_utils.f90(730,11)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 0.139
         remark #15301: REMAINDER LOOP WAS VECTORIZED
      LOOP END

      LOOP BEGIN at comm_utils.f90(730,11)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(737,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable ? was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at comm_utils.f90(738,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (744:13) and Y (744:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between Y (744:13) and at (744:13)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(739,26)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(739,26)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_utils.f90(739,26) ]
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference Y(:,j) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.426
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 8.500 
      remark #15478: estimated potential speedup: 1.040 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(739,26)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at comm_utils.f90(739,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_utils.f90(739,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference Y(:,j) has aligned access
      remark #15388: vectorization support: reference Y(:,j) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.086
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 30 
      remark #15477: vector cost: 17.500 
      remark #15478: estimated potential speedup: 1.690 
      remark #15486: divides: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(739,8)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference Y(:,j) has aligned access
      remark #15388: vectorization support: reference Y(:,j) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.308
      remark #15301: REMAINDER LOOP WAS VECTORIZED
   LOOP END

   LOOP BEGIN at comm_utils.f90(739,8)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at comm_utils.f90(741,8)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable m was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(728,8)
<Multiversioned v1, Distributed chunk2>
   remark #25440: unrolled and jammed by 2   (pre-vector) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(730,11)
      remark #17107: loop was not parallelized: inner loop
      remark #15389: vectorization support: reference bl(l,j) has unaligned access   [ comm_utils.f90(731,32) ]
      remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
      remark #15388: vectorization support: reference bl(l,j) has aligned access   [ comm_utils.f90(731,32) ]
      remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.060
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 160 
      remark #15477: vector cost: 75.500 
      remark #15478: estimated potential speedup: 2.110 
      remark #15486: divides: 2 
      remark #15487: type converts: 2 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(730,11)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at comm_utils.f90(730,11)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(728,8)
<Remainder, Multiversioned v1, Distributed chunk2>
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(730,11)
      remark #15389: vectorization support: reference bl(l,j) has unaligned access   [ comm_utils.f90(731,32) ]
      remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.013
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 80 
      remark #15477: vector cost: 38.000 
      remark #15478: estimated potential speedup: 2.070 
      remark #15486: divides: 1 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(730,11)
   <Remainder loop for vectorization>
      remark #15389: vectorization support: reference bl(l,j) has unaligned access   [ comm_utils.f90(731,32) ]
      remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.175
      remark #15301: REMAINDER LOOP WAS VECTORIZED
   LOOP END

   LOOP BEGIN at comm_utils.f90(730,11)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(728,8)
<Multiversioned v2, Distributed chunk2>
   remark #25440: unrolled and jammed by 2   (pre-vector) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(730,11)
      remark #17107: loop was not parallelized: inner loop
      remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
      remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <bl(l,j)>, stride is unknown to compiler   [ comm_utils.f90(731,32) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <bl(l,j)>, stride is unknown to compiler   [ comm_utils.f90(731,32) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.013
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15452: unmasked strided loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 160 
      remark #15477: vector cost: 77.000 
      remark #15478: estimated potential speedup: 2.070 
      remark #15486: divides: 2 
      remark #15487: type converts: 2 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(730,11)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(728,8)
<Remainder, Multiversioned v2, Distributed chunk2>
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_utils.f90(730,11)
      remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <bl(l,j)>, stride is unknown to compiler   [ comm_utils.f90(731,32) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.003
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 80 
      remark #15477: vector cost: 38.500 
      remark #15478: estimated potential speedup: 2.040 
      remark #15486: divides: 1 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_utils.f90(730,11)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference PL(l) has aligned access   [ comm_utils.f90(731,40) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.139
      remark #15301: REMAINDER LOOP WAS VECTORIZED
   LOOP END

   LOOP BEGIN at comm_utils.f90(730,11)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(708,49):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_utils.f90(709,46):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_utils.f90(708,46):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_utils.f90(737,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
comm_utils.f90(737,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (1, 0)
comm_utils.f90(700,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_compute_radial_beam_] comm_utils.f90:700

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    1327
            Global    :     330
            Local     :     997
        Regenerable   :     228
        Spilled       :      72
        
    Routine stack
        Variables     :     700 bytes*
            Reads     :      35 [1.41e+02 ~ 0.3%]
            Writes    :     105 [1.37e+02 ~ 0.3%]
        Spills        :     608 bytes*
            Reads     :     156 [1.10e+03 ~ 2.5%]
            Writes    :     111 [6.72e+02 ~ 1.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::RAND_TRUNC_GAUSS

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::RAND_TRUNC_GAUSS) [25/28=89.3%] comm_utils.f90(751,12)
  -> EXTERN: (765,15) log
  -> EXTERN: (765,19) RAND_UNI
  -> EXTERN: (766,14) exp
  -> EXTERN: (767,12) RAND_UNI


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(763,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(751,12):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_rand_trunc_gauss_] comm_utils.f90:751

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   10[ rdx rcx rsi rdi r12 zmm0-zmm4]
        
    Routine temporaries
        Total         :      46
            Global    :      20
            Local     :      26
        Regenerable   :       1
        Spilled       :       8
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      56 bytes*
            Reads     :       7 [2.30e+01 ~ 15.5%]
            Writes    :       7 [1.90e+01 ~ 12.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::REPORT_ERROR

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::REPORT_ERROR) [26/28=92.9%] comm_utils.f90(557,14)
  -> EXTERN: (564,10) mpi_comm_rank_
  -> EXTERN: (566,20) for_write_seq_lis
  -> EXTERN: (566,20) __resetsp_inlined
  -> EXTERN: (566,20) __getsp_inlined
  -> EXTERN: (566,31) for_trim
  -> EXTERN: (566,36) _alloca
  -> EXTERN: (567,10) mpi_finalize_
  -> EXTERN: (568,5) for_stop_core


    Report from: Code generation optimizations [cg]

comm_utils.f90(557,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_report_error_] comm_utils.f90:557

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   10[ rax rdx rcx rbx rsi rdi r8 r12-r13 r15]
        
    Routine temporaries
        Total         :      48
            Global    :      15
            Local     :      33
        Regenerable   :      26
        Spilled       :       4
        
    Routine stack
        Variables     :      88 bytes*
            Reads     :       1 [1.00e+00 ~ 2.3%]
            Writes    :       3 [6.60e-01 ~ 1.5%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::INITIALIZE_MONO_DIPOLE

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::INITIALIZE_MONO_DIPOLE) [27/28=96.4%] comm_utils.f90(518,14)
  -> EXTERN: (534,16) PIX2VEC_RING


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(531,5)
<Predicate Optimized v2>
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (534:16) and vec (534:16)
   remark #17106: parallel dependence: assumed OUTPUT dependence between vec (534:16) and at (534:16)
   remark #25422: Invariant Condition at line 532 hoisted out of this loop
   remark #25422: Invariant Condition at line 533 hoisted out of this loop
   remark #15382: vectorization support: call to function PIX2VEC_RING cannot be vectorized   [ comm_utils.f90(534,16) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (534:16) and vec (534:16)
   remark #15346: vector dependence: assumed OUTPUT dependence between vec (534:16) and at (534:16)

   LOOP BEGIN at comm_utils.f90(535,11)
      remark #25436: completely unrolled by 3   (pre-vector) 
   LOOP END
LOOP END

LOOP BEGIN at comm_utils.f90(531,5)
<Predicate Optimized v3>
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <monopole(i)>, stride is unknown to compiler   [ comm_utils.f90(532,31) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15300: LOOP WAS VECTORIZED
   remark #15453: unmasked strided stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 3.000 
   remark #15478: estimated potential speedup: 1.320 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_utils.f90(531,5)
<Remainder loop for vectorization, Predicate Optimized v3>
LOOP END

LOOP BEGIN at comm_utils.f90(531,5)
<Predicate Optimized v3>
   remark #25422: Invariant Condition at line 533 hoisted out of this loop
   remark #15382: vectorization support: call to function PIX2VEC_RING cannot be vectorized   [ comm_utils.f90(534,16) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (534:16) and vec (534:16)
   remark #15346: vector dependence: assumed OUTPUT dependence between vec (534:16) and at (534:16)
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(518,14):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_initialize_mono_dipole_] comm_utils.f90:518

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :      98
            Global    :      36
            Local     :      62
        Regenerable   :      16
        Spilled       :       8
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       6 [3.26e+01 ~ 6.1%]
            Writes    :      16 [3.48e+01 ~ 6.5%]
        Spills        :      64 bytes*
            Reads     :      14 [1.85e+01 ~ 3.5%]
            Writes    :      14 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_UTILS::MATRIX_IS_POSITIVE_DEFINITE

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_UTILS::MATRIX_IS_POSITIVE_DEFINITE) [28/28=100.0%] comm_utils.f90(251,12)
  -> EXTERN: (286,8) for_write_seq_lis_xmit
  -> EXTERN: (286,8) for_write_seq_lis
  -> EXTERN: (287,8) for_stop_core


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_utils.f90(270,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ comm_utils.f90(273,17) ]

   LOOP BEGIN at comm_utils.f90(276,14)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ comm_utils.f90(277,37) ]
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_utils.f90(251,12):remark #34051: REGISTER ALLOCATION : [comm_utils_mp_matrix_is_positive_definite_] comm_utils.f90:251

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   18[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm3]
        
    Routine temporaries
        Total         :      72
            Global    :      27
            Local     :      45
        Regenerable   :      25
        Spilled       :       7
        
    Routine stack
        Variables     :      88 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       4 [1.33e+00 ~ 1.7%]
        Spills        :      40 bytes*
            Reads     :      11 [2.13e+00 ~ 2.7%]
            Writes    :       5 [1.63e+00 ~ 2.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================
