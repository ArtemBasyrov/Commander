Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.

Intel(R) Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 18.0.3.222 Build 20180410

Compiler options: -I/mn/stornext/u3/hke/owl/local/src/dagsshealpix/include -I/mn/stornext/u3/hke/owl/local/include -I/astro/local/opt/Intel/compilers_and_libraries_2018.3.222/linux/mpi/intel64/include -I/astro/local/opt/Intel/compilers_and_libraries_2018.3.222/linux/mpi/intel64/include -O3 -traceback -qopenmp -qopt-report=5 -parallel -c

    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: false
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: false

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

Begin optimization report for: comm_ptsrc_comp_mod._

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (comm_ptsrc_comp_mod._) [1/20=5.0%] comm_ptsrc_comp_mod.f90(1,8)


    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(1,8):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod._] comm_ptsrc_comp_mod.f90:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    0[ reg_null]
        
    Routine temporaries
        Total         :       6
            Global    :       0
            Local     :       6
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::CONSTRUCTOR

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::CONSTRUCTOR) [2/20=10.0%] comm_ptsrc_comp_mod.f90(90,12)
  -> EXTERN: (100,5) for_allocate
  -> EXTERN: (106,5) memcpy
  -> EXTERN: (107,5) memcpy
  -> EXTERN: (108,5) memcpy
  -> EXTERN: (113,5) for_cpystr
  -> EXTERN: (113,35) for_trim
  -> EXTERN: (116,5) for_alloc_allocatable
  -> EXTERN: (123,5) memcpy
  -> EXTERN: (134,5) for_alloc_allocatable
  -> EXTERN: (134,5) for_check_mult_overflow64
  -> EXTERN: (135,18) memmove
  -> EXTERN: (135,18) _alloca
  -> EXTERN: (135,18) for_trim
  -> EXTERN: (136,11) for_cpstr
  -> EXTERN: (138,8) for_check_mult_overflow64
  -> EXTERN: (138,8) for_alloc_allocatable
  -> EXTERN: (138,8) for_check_mult_overflow64
  -> EXTERN: (138,8) for_alloc_allocatable
  -> EXTERN: (139,8) for_check_mult_overflow64
  -> EXTERN: (139,8) for_alloc_allocatable
  -> EXTERN: (140,8) for_check_mult_overflow64
  -> EXTERN: (140,8) for_alloc_allocatable
  -> EXTERN: (140,8) for_check_mult_overflow64
  -> EXTERN: (140,8) for_alloc_allocatable
  -> EXTERN: (141,8) for_realloc_lhs
  -> EXTERN: (142,8) for_realloc_lhs
  -> EXTERN: (143,8) for_realloc_lhs
  -> EXTERN: (144,8) for_realloc_lhs
  -> EXTERN: (145,8) for_realloc_lhs
  -> EXTERN: (147,37) COMM_F_INT_2D_MOD^CONSTRUCTOR
  -> EXTERN: (149,11) for_cpstr
  -> EXTERN: (151,8) for_check_mult_overflow64
  -> EXTERN: (151,8) for_alloc_allocatable
  -> EXTERN: (151,8) for_check_mult_overflow64
  -> EXTERN: (151,8) for_alloc_allocatable
  -> EXTERN: (152,8) for_check_mult_overflow64
  -> EXTERN: (152,8) for_alloc_allocatable
  -> EXTERN: (153,8) for_check_mult_overflow64
  -> EXTERN: (153,8) for_alloc_allocatable
  -> EXTERN: (153,8) for_check_mult_overflow64
  -> EXTERN: (153,8) for_alloc_allocatable
  -> EXTERN: (154,8) for_realloc_lhs
  -> EXTERN: (155,8) for_realloc_lhs
  -> EXTERN: (156,8) for_realloc_lhs
  -> EXTERN: (157,8) for_realloc_lhs
  -> EXTERN: (158,8) for_realloc_lhs
  -> EXTERN: (160,37) COMM_F_INT_2D_MOD^CONSTRUCTOR
  -> EXTERN: (162,11) for_cpstr
  -> EXTERN: (165,37) COMM_F_INT_0D_MOD^CONSTRUCTOR
  -> EXTERN: (168,13) __resetsp_inlined
  -> EXTERN: (168,13) __resetsp_inlined
  -> EXTERN: (168,13) REPORT_ERROR
  -> EXTERN: (168,13) __getsp_inlined
  -> EXTERN: (168,13) __getsp_inlined
  -> EXTERN: (168,57) for_concat
  -> EXTERN: (168,57) _alloca
  -> EXTERN: (168,60) for_trim
  -> (172,10) COMM_PTSRC_COMP_MOD::READ_SOURCES (isz = 6231) (sz = 6242)
     [[ Inlining would exceed -inline-max-total-size value (6231>2000) <1>]]
  -> INDIRECT-: (175,10)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_constructor_$CONSTRUCTOR_V$3783.0.2 + 56(SI64)))))[15(SI64)]
     [[ Unable to inline indirect callsite  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(117,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(117,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference at (117:5) has aligned access
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 4.333
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.750 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(117,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(141,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (141:8) and cpar(id_abs,:,:) (141:8)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:,:) (141:8) and at (141:8)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (141:8) and cpar(id_abs,:,:) (141:8)
   remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:,:) (141:8) and at (141:8)

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(141,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between at (141:8) and cpar(id_abs,:,:) (141:8)
      remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:,:) (141:8) and at (141:8)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between at (141:8) and cpar(id_abs,:,:) (141:8)
      remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:,:) (141:8) and at (141:8)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(141,8)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(142,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (142:8) and cpar(id_abs,:,:) (142:8)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:,:) (142:8) and at (142:8)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (142:8) and cpar(id_abs,:,:) (142:8)
   remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:,:) (142:8) and at (142:8)

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(142,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between at (142:8) and cpar(id_abs,:,:) (142:8)
      remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:,:) (142:8) and at (142:8)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between at (142:8) and cpar(id_abs,:,:) (142:8)
      remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:,:) (142:8) and at (142:8)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(142,8)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(143,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (143:8) and cpar(:,id_abs) (143:8)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(:,id_abs) (143:8) and at (143:8)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (143:8) and cpar(:,id_abs) (143:8)
   remark #15346: vector dependence: assumed ANTI dependence between cpar(:,id_abs) (143:8) and at (143:8)
   remark #25436: completely unrolled by 2  
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(144,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (144:8) and cpar(id_abs,:) (144:8)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:) (144:8) and at (144:8)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (144:8) and cpar(id_abs,:) (144:8)
   remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:) (144:8) and at (144:8)
   remark #25436: completely unrolled by 2  
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(145,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (145:8) and cpar(id_abs,:) (145:8)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:) (145:8) and at (145:8)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (145:8) and cpar(id_abs,:) (145:8)
   remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:) (145:8) and at (145:8)
   remark #25436: completely unrolled by 2  
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(146,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (147:37) and constructor(i) (147:11)
   remark #17106: parallel dependence: assumed OUTPUT dependence between constructor(i) (147:11) and at (147:37)
   remark #15382: vectorization support: call to function COMM_F_INT_2D_MOD^CONSTRUCTOR cannot be vectorized   [ comm_ptsrc_comp_mod.f90(147,37) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (147:37) and constructor(i) (147:11)
   remark #15346: vector dependence: assumed OUTPUT dependence between constructor(i) (147:11) and at (147:37)
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(154,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (154:8) and cpar(id_abs,:,:) (154:8)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:,:) (154:8) and at (154:8)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (154:8) and cpar(id_abs,:,:) (154:8)
   remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:,:) (154:8) and at (154:8)

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(154,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between at (154:8) and cpar(id_abs,:,:) (154:8)
      remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:,:) (154:8) and at (154:8)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between at (154:8) and cpar(id_abs,:,:) (154:8)
      remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:,:) (154:8) and at (154:8)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(154,8)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(155,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (155:8) and cpar(id_abs,:,:) (155:8)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:,:) (155:8) and at (155:8)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (155:8) and cpar(id_abs,:,:) (155:8)
   remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:,:) (155:8) and at (155:8)

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(155,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between at (155:8) and cpar(id_abs,:,:) (155:8)
      remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:,:) (155:8) and at (155:8)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between at (155:8) and cpar(id_abs,:,:) (155:8)
      remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:,:) (155:8) and at (155:8)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(155,8)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(156,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (156:8) and cpar(:,id_abs) (156:8)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(:,id_abs) (156:8) and at (156:8)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (156:8) and cpar(:,id_abs) (156:8)
   remark #15346: vector dependence: assumed ANTI dependence between cpar(:,id_abs) (156:8) and at (156:8)
   remark #25436: completely unrolled by 2  
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(157,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (157:8) and cpar(id_abs,:) (157:8)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:) (157:8) and at (157:8)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (157:8) and cpar(id_abs,:) (157:8)
   remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:) (157:8) and at (157:8)
   remark #25436: completely unrolled by 2  
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(158,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (158:8) and cpar(id_abs,:) (158:8)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs,:) (158:8) and at (158:8)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (158:8) and cpar(id_abs,:) (158:8)
   remark #15346: vector dependence: assumed ANTI dependence between cpar(id_abs,:) (158:8) and at (158:8)
   remark #25436: completely unrolled by 2  
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(159,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (160:37) and constructor(i) (160:11)
   remark #17106: parallel dependence: assumed OUTPUT dependence between constructor(i) (160:11) and at (160:37)
   remark #15382: vectorization support: call to function COMM_F_INT_2D_MOD^CONSTRUCTOR cannot be vectorized   [ comm_ptsrc_comp_mod.f90(160,37) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (160:37) and constructor(i) (160:11)
   remark #15346: vector dependence: assumed OUTPUT dependence between constructor(i) (160:11) and at (160:37)
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(164,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (165:37) and constructor(i) (165:11)
   remark #17106: parallel dependence: assumed OUTPUT dependence between constructor(i) (165:11) and at (165:37)
   remark #15382: vectorization support: call to function COMM_F_INT_0D_MOD^CONSTRUCTOR cannot be vectorized   [ comm_ptsrc_comp_mod.f90(165,37) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (165:37) and constructor(i) (165:11)
   remark #15346: vector dependence: assumed OUTPUT dependence between constructor(i) (165:11) and at (165:37)
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(100,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(100,5):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(106,5):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(106,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
comm_ptsrc_comp_mod.f90(106,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (1, 0)
comm_ptsrc_comp_mod.f90(107,5):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(107,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
comm_ptsrc_comp_mod.f90(107,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (1, 0)
comm_ptsrc_comp_mod.f90(108,5):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(108,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
comm_ptsrc_comp_mod.f90(108,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (1, 0)
comm_ptsrc_comp_mod.f90(123,5):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(123,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
comm_ptsrc_comp_mod.f90(123,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (8, 0)
comm_ptsrc_comp_mod.f90(135,18):remark #34014: optimization advice for memmove: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(135,18):remark #34026: call to memmove implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(90,12):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_constructor_] comm_ptsrc_comp_mod.f90:90

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   18[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm3]
        
    Routine temporaries
        Total         :    1676
            Global    :     173
            Local     :    1503
        Regenerable   :     135
        Spilled       :      44
        
    Routine stack
        Variables     :    2856 bytes*
            Reads     :      50 [5.82e+01 ~ 3.6%]
            Writes    :     126 [4.89e+01 ~ 3.0%]
        Spills        :     280 bytes*
            Reads     :      82 [2.47e+01 ~ 1.5%]
            Writes    :      50 [9.47e+00 ~ 0.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::READ_SOURCES

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::READ_SOURCES) [3/20=15.0%] comm_ptsrc_comp_mod.f90(475,14)
  -> EXTERN: (490,12) GETLUN
  -> EXTERN: (493,18) memmove
  -> EXTERN: (493,18) _alloca
  -> EXTERN: (493,18) for_trim
  -> EXTERN: (494,11) for_cpstr
  -> EXTERN: (496,11) for_cpstr
  -> EXTERN: (498,11) for_cpstr
  -> EXTERN: (499,8) __resetsp_inlined
  -> EXTERN: (499,8) __getsp_inlined
  -> EXTERN: (501,5) for_alloc_allocatable
  -> EXTERN: (501,5) for_check_mult_overflow64
  -> EXTERN: (501,5) for_alloc_allocatable
  -> EXTERN: (501,5) for_check_mult_overflow64
  -> EXTERN: (501,5) for_alloc_allocatable
  -> EXTERN: (501,5) for_check_mult_overflow64
  -> EXTERN: (501,5) for_alloc_allocatable
  -> EXTERN: (501,5) for_check_mult_overflow64
  -> EXTERN: (504,5) __resetsp_inlined
  -> EXTERN: (504,5) for_open
  -> EXTERN: (504,5) __getsp_inlined
  -> EXTERN: (504,20) for_trim
  -> EXTERN: (504,46) for_concat
  -> EXTERN: (504,46) _alloca
  -> EXTERN: (504,49) for_trim
  -> EXTERN: (509,8) for_read_seq_fmt
  -> EXTERN: (510,8) for_cpystr
  -> EXTERN: (510,15) for_trim
  -> EXTERN: (511,34) for_trim
  -> EXTERN: (511,45) for_cpstr
  -> EXTERN: (521,11) for_close
  -> EXTERN: (523,25) REPORT_ERROR
  -> EXTERN: (523,25) __resetsp_inlined
  -> EXTERN: (523,25) __getsp_inlined
  -> EXTERN: (523,68) _alloca
  -> EXTERN: (523,68) for_concat
  -> EXTERN: (524,12) for_trim
  -> EXTERN: (524,17) for_trim
  -> EXTERN: (524,43) _alloca
  -> EXTERN: (524,43) for_concat
  -> EXTERN: (524,43) _alloca
  -> EXTERN: (524,46) for_trim
  -> EXTERN: (527,5) for_alloc_allocatable
  -> EXTERN: (527,5) for_check_mult_overflow64
  -> EXTERN: (527,5) for_alloc_allocatable
  -> EXTERN: (527,5) for_check_mult_overflow64
  -> EXTERN: (528,5) for_alloc_allocatable
  -> EXTERN: (528,5) for_check_mult_overflow64
  -> EXTERN: (528,5) for_alloc_allocatable
  -> EXTERN: (528,5) for_check_mult_overflow64
  -> EXTERN: (529,5) __resetsp_inlined
  -> EXTERN: (529,5) for_open
  -> EXTERN: (529,5) __getsp_inlined
  -> EXTERN: (529,20) for_trim
  -> EXTERN: (529,46) for_concat
  -> EXTERN: (529,46) _alloca
  -> EXTERN: (529,49) for_trim
  -> EXTERN: (533,8) for_read_seq_fmt
  -> EXTERN: (534,8) for_cpystr
  -> EXTERN: (534,15) for_trim
  -> EXTERN: (535,34) for_trim
  -> EXTERN: (535,45) for_cpstr
  -> EXTERN: (536,8) for_read_int_lis_xmit
  -> EXTERN: (536,8) for_read_int_lis_xmit
  -> EXTERN: (536,8) for_read_int_lis_xmit
  -> EXTERN: (536,8) for_read_int_lis_xmit
  -> EXTERN: (536,8) for_read_int_lis_xmit
  -> EXTERN: (536,8) for_read_int_lis_xmit
  -> EXTERN: (536,8) for_read_int_lis
  -> EXTERN: (537,8) for_realloc_lhs
  -> EXTERN: (540,13) ANG2VEC
  -> EXTERN: (542,16) ANGDIST
  -> EXTERN: (552,11) for_alloc_allocatable
  -> EXTERN: (552,11) for_check_mult_overflow64
  -> EXTERN: (552,11) for_alloc_allocatable
  -> EXTERN: (552,11) for_check_mult_overflow64
  -> EXTERN: (553,11) for_alloc_allocatable
  -> EXTERN: (553,11) for_check_mult_overflow64
  -> EXTERN: (554,11) for_alloc_allocatable
  -> EXTERN: (554,11) for_check_mult_overflow64
  -> EXTERN: (555,11) for_alloc_allocatable
  -> EXTERN: (555,11) for_check_mult_overflow64
  -> EXTERN: (556,11) for_alloc_allocatable
  -> EXTERN: (556,11) for_check_mult_overflow64
  -> EXTERN: (557,11) for_cpystr
  -> EXTERN: (560,11) for_realloc_lhs
  -> EXTERN: (560,11) for_dealloc_allocatable
  -> EXTERN: (571,16) ANG2PIX_RING
  -> EXTERN: (572,15) LOCATE_INT
  -> EXTERN: (587,11) for_close
  -> EXTERN: (590,10) mpi_allreduce_
  -> EXTERN: (601,5) for_dealloc_allocatable
  -> EXTERN: (601,5) for_dealloc_allocatable
  -> EXTERN: (604,5) for_concat
  -> EXTERN: (604,16) for_trim
  -> EXTERN: (604,41) for_trim
  -> EXTERN: (607,15) for_write_seq_fmt
  -> EXTERN: (607,15) for_write_seq_fmt_xmit
  -> EXTERN: (607,15) for_write_seq_fmt_xmit
  -> EXTERN: (607,15) for_write_seq_fmt_xmit
  -> EXTERN: (611,11) for_check_mult_overflow64
  -> EXTERN: (611,11) for_alloc_allocatable
  -> EXTERN: (615,15) for_trim
  -> EXTERN: (615,52) for_cpstr
  -> (617,19) COMM_PTSRC_COMP_MOD::READ_FEBECOP_BEAM (isz = 2321) (sz = 2342)
     [[ Inlining would exceed -inline-max-size value (2342>230) <3>]]
  -> EXTERN: (620,14) for_concat
  -> EXTERN: (620,25) for_trim
  -> EXTERN: (620,50) for_trim
  -> EXTERN: (621,29) for_trim
  -> EXTERN: (621,34) for_adjustl
  -> EXTERN: (622,34) for_cpstr
  -> (624,22) COMM_PTSRC_COMP_MOD::READ_FEBECOP_BEAM (isz = 2321) (sz = 2342)
     [[ Inlining would exceed -inline-max-size value (2342>230) <3>]]
  -> EXTERN: (626,23) for_trim
  -> EXTERN: (626,28) for_trim
  -> EXTERN: (626,28) _alloca
  -> EXTERN: (626,58) __getsp_inlined
  -> EXTERN: (626,58) __resetsp_inlined
  -> EXTERN: (626,58) for_cpstr
  -> (628,22) COMM_PTSRC_COMP_MOD::COMPUTE_SYMMETRIC_BEAM (isz = 2235) (sz = 2252)
     [[ Inlining would exceed -inline-max-size value (2252>253) <3>]]
  -> EXTERN: (630,39) for_cpstr
  -> EXTERN: (630,70) for_cpstr
  -> (632,22) COMM_PTSRC_COMP_MOD::COMPUTE_SYMMETRIC_BEAM (isz = 2235) (sz = 2252)
     [[ Inlining would exceed -inline-max-size value (2252>253) <3>]]
  -> EXTERN: (635,22) __getsp_inlined
  -> EXTERN: (635,22) REPORT_ERROR
  -> EXTERN: (635,22) __resetsp_inlined
  -> EXTERN: (635,73) _alloca
  -> EXTERN: (635,73) for_concat
  -> EXTERN: (635,75) for_trim
  -> (640,44) COMM_PTSRC_COMP_MOD::DUMP_BEAMS_TO_HDF (isz = 2155) (sz = 2164)
     [[ Inlining would exceed -inline-max-size value (2164>253) <3>]]
  -> EXTERN: (654,5) for_dealloc_allocatable
  -> EXTERN: (654,5) for_dealloc_allocatable
  -> EXTERN: (654,5) for_dealloc_allocatable
  -> EXTERN: (654,5) for_dealloc_allocatable
  -> EXTERN: (656,3) for_dealloc_allocatable
  -> EXTERN: (656,3) for_dealloc_allocatable
  -> EXTERN: (656,3) for_dealloc_allocatable
  -> EXTERN: (656,3) for_dealloc_allocatable
  -> EXTERN: (656,3) for_dealloc_allocatable
  -> EXTERN: (656,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(507,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(527,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable ? was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(537,8)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference AMP_RMS(:) has aligned access
   remark #15388: vectorization support: reference AMP_RMS(:) has aligned access   [ comm_ptsrc_comp_mod.f90(537,28) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.083
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 6 
   remark #15477: vector cost: 3.000 
   remark #15478: estimated potential speedup: 1.960 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(537,8)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference AMP_RMS(:) has aligned access
   remark #15388: vectorization support: reference AMP_RMS(:) has aligned access   [ comm_ptsrc_comp_mod.f90(537,28) ]
   remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 1.200
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(541,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (542:16) and cpar(id_abs) (543:34)
   remark #17106: parallel dependence: assumed ANTI dependence between cpar(id_abs) (543:34) and at (542:16)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ comm_ptsrc_comp_mod.f90(543,34) ]
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(552,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable ? was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(560,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (560:11) and at (560:11)
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (560:11) and at (560:11)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(560,11)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (560:11) and at (560:11)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (560:11) and at (560:11)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(560,11)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(560,11)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (560:11) has aligned access
         remark #15388: vectorization support: reference BETA(:,:) has aligned access
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 5.000
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 1.260 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(560,11)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(560,11)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(561,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference AMP(:) has aligned access   [ comm_ptsrc_comp_mod.f90(561,46) ]
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <self(i,:)>, stride is unknown to compiler
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.013
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15453: unmasked strided stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 30 
   remark #15477: vector cost: 19.000 
   remark #15478: estimated potential speedup: 1.560 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(561,11)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference AMP(:) has aligned access   [ comm_ptsrc_comp_mod.f90(561,46) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(561,11)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(562,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (562:11) and vec(:) (562:11)
   remark #17106: parallel dependence: assumed ANTI dependence between vec(:) (562:11) and at (562:11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between at (562:11) and vec(:) (562:11)
   remark #15346: vector dependence: assumed ANTI dependence between vec(:) (562:11) and at (562:11)
   remark #25436: completely unrolled by 3  
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(563,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference at (563:11) has unaligned access
   remark #15388: vectorization support: reference AMP(:) has aligned access   [ comm_ptsrc_comp_mod.f90(563,50) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.034
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 30 
   remark #15477: vector cost: 18.500 
   remark #15478: estimated potential speedup: 1.600 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(563,11)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference at (563:11) has unaligned access
   remark #15388: vectorization support: reference AMP(:) has aligned access   [ comm_ptsrc_comp_mod.f90(563,50) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.366
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(563,11)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(564,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference at (564:11) has unaligned access
   remark #15388: vectorization support: reference AMP_RMS(:) has aligned access   [ comm_ptsrc_comp_mod.f90(564,50) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.034
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 30 
   remark #15477: vector cost: 18.500 
   remark #15478: estimated potential speedup: 1.600 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(564,11)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference at (564:11) has unaligned access
   remark #15388: vectorization support: reference AMP_RMS(:) has aligned access   [ comm_ptsrc_comp_mod.f90(564,50) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.366
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(564,11)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(565,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (565:11) and at (565:11)
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (565:11) and at (565:11)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(565,11)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (565:11) and at (565:11)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (565:11) and at (565:11)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(565,11)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(565,11)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (565:11) has aligned access
         remark #15388: vectorization support: reference BETA(:,:) has aligned access
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 5.000
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 1.260 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(565,11)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(565,11)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(566,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (566:11) and at (566:11)
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (566:11) and at (566:11)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(566,11)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (566:11) and at (566:11)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (566:11) and at (566:11)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(566,11)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(566,11)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (566:11) has aligned access
         remark #15388: vectorization support: reference BETA_RMS(:,:) has aligned access
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 5.000
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 1.260 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(566,11)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(566,11)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(578,26)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <data_(1,p,j)>, stride is unknown to compiler   [ comm_ptsrc_comp_mod.f90(577,27) ]
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <MASK(i,j)>, masked, stride is unknown to compiler
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15452: unmasked strided loads: 1 
   remark #15462: unmasked indexed (or gather) loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 21 
   remark #15477: vector cost: 23.000 
   remark #15478: estimated potential speedup: 0.910 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(578,26)
<Remainder>
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(531,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(531,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(531,5)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference MASK(:,:) has aligned access
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 3.333
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 2 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 2.500 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(531,5)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(605,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between self (606:28) and at (607:15)
   remark #17106: parallel dependence: assumed FLOW dependence between at (607:15) and self (606:28)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(608,8)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(612,11)
         remark #25408: memset generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between at (612:11) and at (612:11)
         remark #17106: parallel dependence: assumed OUTPUT dependence between at (612:11) and at (612:11)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(612,11)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15389: vectorization support: reference at (612:11) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 2
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.300
            remark #15300: LOOP WAS VECTORIZED
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 2.500 
            remark #15478: estimated potential speedup: 1.450 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(612,11)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END


Non-optimizable loops:


LOOP BEGIN at comm_ptsrc_comp_mod.f90(535,29)
   remark #15533: loop was not vectorized: loop exceeds complexity limits. Consider overriding limits (-override-limits) or using simd directive.
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(488,56):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(488,50):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(487,52):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(486,46):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(487,46):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(486,51):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(493,18):remark #34014: optimization advice for memmove: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(493,18):remark #34026: call to memmove implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(527,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(527,5):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(552,11):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
comm_ptsrc_comp_mod.f90(552,11):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (1, 0)
comm_ptsrc_comp_mod.f90(560,11):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(560,11):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(560,11):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(565,11):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(565,11):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(565,11):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(566,11):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(566,11):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(566,11):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(612,11):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(612,11):remark #34026: call to memset implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(475,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_read_sources_] comm_ptsrc_comp_mod.f90:475

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   24[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm9]
        
    Routine temporaries
        Total         :    2636
            Global    :     408
            Local     :    2228
        Regenerable   :     461
        Spilled       :      63
        
    Routine stack
        Variables     :   18776 bytes*
            Reads     :     124 [2.02e+02 ~ 2.2%]
            Writes    :     243 [3.98e+02 ~ 4.2%]
        Spills        :     448 bytes*
            Reads     :     107 [1.37e+02 ~ 1.5%]
            Writes    :      77 [3.71e+01 ~ 0.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::COMPUTE_SYMMETRIC_BEAM

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::COMPUTE_SYMMETRIC_BEAM) [4/20=20.0%] comm_ptsrc_comp_mod.f90(828,14)
  -> EXTERN: (849,27) for_deallocate_all
  -> EXTERN: (851,16) COMPUTE_RADIAL_BEAM
  -> (853,16) COMM_PTSRC_COMP_MOD::READ_RADIAL_BEAM (isz = 1167) (sz = 1178)
     [[ Inlining inhibited by overrideable criterion  <4>]]
  -> EXTERN: (869,10) ANG2VEC
  -> EXTERN: (870,5) for_alloc_allocatable
  -> EXTERN: (870,5) for_check_mult_overflow64
  -> EXTERN: (870,5) for_alloc_allocatable
  -> EXTERN: (870,5) for_check_mult_overflow64
  -> EXTERN: (871,10) QUERY_DISC
  -> EXTERN: (879,13) PIX2VEC_RING
  -> EXTERN: (880,13) ANGDIST
  -> EXTERN: (886,26) SPLINT_SIMPLE
  -> EXTERN: (888,16) RING2NEST
  -> EXTERN: (890,16) NEST2RING
  -> EXTERN: (917,5) for_alloc_allocatable
  -> EXTERN: (917,5) for_check_mult_overflow64
  -> EXTERN: (917,5) for_alloc_allocatable
  -> EXTERN: (917,5) for_check_mult_overflow64
  -> EXTERN: (920,12) LOCATE_INT
  -> EXTERN: (952,10) mpi_allreduce_
  -> EXTERN: (954,10) mpi_allreduce_
  -> EXTERN: (957,5) for_alloc_allocatable
  -> EXTERN: (957,5) for_check_mult_overflow64
  -> EXTERN: (957,5) for_alloc_allocatable
  -> EXTERN: (957,5) for_check_mult_overflow64
  -> EXTERN: (957,5) for_alloc_allocatable
  -> EXTERN: (957,5) for_check_mult_overflow64
  -> EXTERN: (958,5) for_realloc_lhs
  -> EXTERN: (964,5) for_dealloc_allocatable
  -> EXTERN: (964,5) for_dealloc_allocatable
  -> EXTERN: (964,5) for_dealloc_allocatable
  -> EXTERN: (964,5) for_dealloc_allocatable
  -> EXTERN: (966,3) for_dealloc_allocatable
  -> EXTERN: (966,3) for_dealloc_allocatable
  -> EXTERN: (966,3) for_dealloc_allocatable
  -> EXTERN: (966,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(864,5)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(865,8) ]
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(865,25)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(865,25)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(865,25) ]
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference BR(i,:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.441
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 8.500 
      remark #15478: estimated potential speedup: 1.040 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(865,25)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(878,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (879:13) and vec (879:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between vec (879:13) and at (879:13)
   remark #15382: vectorization support: call to function PIX2VEC_RING cannot be vectorized   [ comm_ptsrc_comp_mod.f90(879,13) ]
   remark #15382: vectorization support: call to function ANGDIST cannot be vectorized   [ comm_ptsrc_comp_mod.f90(880,13) ]
   remark #15382: vectorization support: call to function SPLINT_SIMPLE cannot be vectorized   [ comm_ptsrc_comp_mod.f90(886,26) ]
   remark #15382: vectorization support: call to function RING2NEST cannot be vectorized   [ comm_ptsrc_comp_mod.f90(888,16) ]
   remark #15382: vectorization support: call to function NEST2RING cannot be vectorized   [ comm_ptsrc_comp_mod.f90(890,16) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (879:13) and LISTPIX(i) (890:16)
   remark #15346: vector dependence: assumed OUTPUT dependence between LISTPIX(i) (890:16) and at (879:13)

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(885,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #15382: vectorization support: call to function SPLINT_SIMPLE cannot be vectorized   [ comm_ptsrc_comp_mod.f90(886,26) ]
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(901,8)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between LISTPIX(i) (900:8) and LISTPIX(j+1) (909:8)
   remark #17106: parallel dependence: assumed FLOW dependence between LISTPIX(j+1) (909:8) and LISTPIX(i) (900:8)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(901,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference rtmp(:) has aligned access
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <BEAM(i,:)>, stride is unknown to compiler
      remark #15305: vectorization support: vector length 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 2.500 
      remark #15478: estimated potential speedup: 1.330 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(901,8)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(903,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between LISTPIX(j) (904:26) and LISTPIX(j+1) (905:11)
      remark #17106: parallel dependence: assumed FLOW dependence between LISTPIX(j+1) (905:11) and LISTPIX(j) (904:26)
      remark #17106: parallel dependence: assumed ANTI dependence between LISTPIX(j) (905:11) and LISTPIX(j+1) (905:11)
      remark #17106: parallel dependence: assumed FLOW dependence between LISTPIX(j+1) (905:11) and LISTPIX(j) (905:11)
      remark #17106: parallel dependence: assumed ANTI dependence between BEAM(j,:) (906:11) and BEAM(j+1,:) (906:11)
      remark #17106: parallel dependence: assumed FLOW dependence between BEAM(j+1,:) (906:11) and BEAM(j,:) (906:11)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ comm_ptsrc_comp_mod.f90(907,11) ]

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(906,11)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
         remark #15329: vectorization support: non-unit strided store was emulated for the variable <BEAM(j+1,:)>, stride is unknown to compiler
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <BEAM(j,:)>, stride is unknown to compiler
         remark #15305: vectorization support: vector length 2
         remark #15452: unmasked strided loads: 1 
         remark #15453: unmasked strided stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 4.000 
         remark #15478: estimated potential speedup: 1.000 
         remark #15488: --- end vector cost summary ---
         remark #25439: unrolled with remainder by 2  
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(906,11)
      <Remainder>
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(910,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference rtmp(:) has aligned access
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <BEAM(j+1,:)>, stride is unknown to compiler
      remark #15305: vectorization support: vector length 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 1.200 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(910,8)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(923,29)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(927,14)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <MYBEAM(t%NP,:)>, stride is unknown to compiler
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <BEAM(i,:)>, stride is unknown to compiler
      remark #15305: vectorization support: vector length 2
      remark #15452: unmasked strided loads: 1 
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 4.000 
      remark #15478: estimated potential speedup: 1.000 
      remark #15488: --- end vector cost summary ---
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(927,14)
   <Remainder>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(928,14)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between MYBEAM(t%NP,:) (931:20) and MYBEAM(t%NP,:) (931:20)
      remark #17106: parallel dependence: assumed OUTPUT dependence between MYBEAM(t%NP,:) (931:20) and MYBEAM(t%NP,:) (931:20)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ comm_ptsrc_comp_mod.f90(931,20) ]

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(931,20)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
         remark #15329: vectorization support: non-unit strided store was emulated for the variable <MYBEAM(t%NP,:)>, stride is unknown to compiler
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <BEAM(i,:)>, stride is unknown to compiler
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <MYBEAM(t%NP,:)>, stride is unknown to compiler
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.083
         remark #15452: unmasked strided loads: 2 
         remark #15453: unmasked strided stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 6.000 
         remark #15478: estimated potential speedup: 0.990 
         remark #15488: --- end vector cost summary ---
         remark #25439: unrolled with remainder by 2  
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(931,20)
      <Remainder>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(948,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized
   remark #25015: Estimate of max trip count of loop=3

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(949,19)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(949,19)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(949,19) ]
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference MYBEAM(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.426
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 8.500 
      remark #15478: estimated potential speedup: 1.040 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(949,19)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(950,19)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(950,19)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference MYBEAM(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 1.450
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 6 
      remark #15477: vector cost: 2.500 
      remark #15478: estimated potential speedup: 2.260 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(950,19)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(958,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between t(:,:) (958:5) and t(:,:) (958:5)
   remark #17106: parallel dependence: assumed OUTPUT dependence between t(:,:) (958:5) and t(:,:) (958:5)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(958,5)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between t(:,:) (958:5) and t(:,:) (958:5)
      remark #17106: parallel dependence: assumed OUTPUT dependence between t(:,:) (958:5) and t(:,:) (958:5)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(958,5)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(958,5)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference t(:,:) has aligned access
         remark #15388: vectorization support: reference MYPIX(:,:) has aligned access
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 4.667
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 0.750 
         remark #15478: estimated potential speedup: 2.130 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(958,5)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(958,5)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=24
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(961,10)
   remark #17109: LOOP WAS AUTO-PARALLELIZED
   remark #17101: parallel loop shared={ b_max b_tot } private={ } firstprivate={ ? ? ? MYBEAM i } lastprivate={ } firstlastprivate={ } reduction={ }
   remark #15542: loop was not vectorized: inner loop was already vectorized
   remark #25015: Estimate of max trip count of loop=3

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(960,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(960,8)
      remark #15388: vectorization support: reference t(:,i) has aligned access
      remark #15388: vectorization support: reference MYBEAM(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.114
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 30 
      remark #15477: vector cost: 17.500 
      remark #15478: estimated potential speedup: 1.690 
      remark #15486: divides: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(960,8)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(960,8)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference t(:,i) has aligned access
      remark #15389: vectorization support: reference MYBEAM(:,i) has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.375
      remark #15301: REMAINDER LOOP WAS VECTORIZED
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(960,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(961,10)
   remark #15542: loop was not vectorized: inner loop was already vectorized
   remark #25015: Estimate of max trip count of loop=3

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(960,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(960,8)
      remark #17107: loop was not parallelized: inner loop
      remark #15388: vectorization support: reference t(:,i) has aligned access
      remark #15388: vectorization support: reference MYBEAM(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.114
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 30 
      remark #15477: vector cost: 17.500 
      remark #15478: estimated potential speedup: 1.690 
      remark #15486: divides: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(960,8)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(960,8)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference t(:,i) has aligned access
      remark #15389: vectorization support: reference MYBEAM(:,i) has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.375
      remark #15301: REMAINDER LOOP WAS VECTORIZED
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(960,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(841,59):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(841,65):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(840,59):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(839,59):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(958,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(958,5):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(958,5):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(828,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_compute_symmetric_beam_] comm_ptsrc_comp_mod.f90:828

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   22[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm7]
        
    Routine temporaries
        Total         :    1254
            Global    :     299
            Local     :     955
        Regenerable   :     193
        Spilled       :      71
        
    Routine stack
        Variables     :    1168 bytes*
            Reads     :      68 [1.59e+02 ~ 2.0%]
            Writes    :     156 [2.68e+02 ~ 3.4%]
        Spills        :     592 bytes*
            Reads     :     139 [2.36e+02 ~ 3.0%]
            Writes    :     104 [1.09e+02 ~ 1.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::READ_RADIAL_BEAM

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::READ_RADIAL_BEAM) [5/20=25.0%] comm_ptsrc_comp_mod.f90(1229,14)
  -> EXTERN: (1229,48) for_dealloc_all_nopdtlen
  -> EXTERN: (1241,12) GETLUN
  -> EXTERN: (1242,5) __resetsp_inlined
  -> EXTERN: (1242,5) for_open
  -> EXTERN: (1242,5) __getsp_inlined
  -> EXTERN: (1242,20) for_trim
  -> EXTERN: (1242,25) _alloca
  -> EXTERN: (1245,8) for_read_seq_fmt
  -> EXTERN: (1246,8) for_cpystr
  -> EXTERN: (1246,15) for_trim
  -> EXTERN: (1246,20) for_adjustl
  -> EXTERN: (1250,11) for_close
  -> EXTERN: (1252,5) for_alloc_allocatable
  -> EXTERN: (1252,5) for_check_mult_overflow64
  -> EXTERN: (1252,5) for_alloc_allocatable
  -> EXTERN: (1252,5) for_check_mult_overflow64
  -> EXTERN: (1254,5) __resetsp_inlined
  -> EXTERN: (1254,5) for_open
  -> EXTERN: (1254,5) __getsp_inlined
  -> EXTERN: (1254,20) for_trim
  -> EXTERN: (1254,25) _alloca
  -> EXTERN: (1256,8) for_read_seq_fmt
  -> EXTERN: (1257,8) for_cpystr
  -> EXTERN: (1257,15) for_trim
  -> EXTERN: (1257,20) for_adjustl
  -> EXTERN: (1260,8) for_read_int_lis_xmit
  -> EXTERN: (1260,8) for_read_int_lis_xmit
  -> EXTERN: (1260,8) _alloca
  -> EXTERN: (1260,8) for_read_int_lis
  -> EXTERN: (1260,8) __getsp_inlined
  -> EXTERN: (1260,8) __resetsp_inlined
  -> EXTERN: (1262,11) for_close
  -> EXTERN: (1265,5) for_alloc_allocatable
  -> EXTERN: (1265,5) for_check_mult_overflow64
  -> EXTERN: (1267,8) for_realloc_lhs
  -> EXTERN: (1269,13) SPLINE_SIMPLE
  -> EXTERN: (1272,5) for_dealloc_allocatable
  -> EXTERN: (1272,5) for_dealloc_allocatable
  -> EXTERN: (1274,3) for_dealloc_allocatable
  -> EXTERN: (1274,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(1243,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1254,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1260,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference at (1260:27) has aligned access   [ comm_ptsrc_comp_mod.f90(1260,27) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <Y(n,:)>, stride is unknown to compiler   [ comm_ptsrc_comp_mod.f90(1260,27) ]
      remark #15305: vectorization support: vector length 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 2.500 
      remark #15478: estimated potential speedup: 1.600 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1260,8)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1260,27)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference at (1260:27) has aligned access
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <Y(n,:)>, stride is unknown to compiler
      remark #15305: vectorization support: vector length 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 1.330 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1260,27)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1265,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable ? was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1266,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between X_V%X_V(0) (1267:8) and x (1269:13)
   remark #17106: parallel dependence: assumed FLOW dependence between x (1269:13) and X_V%X_V(0) (1267:8)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1267,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference X(:) has aligned access
      remark #15388: vectorization support: reference X(:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 6 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 1.970 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1267,8)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference X(:) has aligned access
      remark #15388: vectorization support: reference X(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.000
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1268,26)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1268,26)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(1268,26) ]
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference Y(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.426
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 8.500 
      remark #15478: estimated potential speedup: 1.040 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1268,26)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1268,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1268,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference Y(:,i) has aligned access
      remark #15388: vectorization support: reference Y(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.086
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 30 
      remark #15477: vector cost: 17.500 
      remark #15478: estimated potential speedup: 1.690 
      remark #15486: divides: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1268,8)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference Y(:,i) has aligned access
      remark #15388: vectorization support: reference Y(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.308
      remark #15301: REMAINDER LOOP WAS VECTORIZED
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1268,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(1238,46):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1237,46):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1265,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
comm_ptsrc_comp_mod.f90(1265,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (1, 0)
comm_ptsrc_comp_mod.f90(1229,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_read_radial_beam_] comm_ptsrc_comp_mod.f90:1229

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :     581
            Global    :     130
            Local     :     451
        Regenerable   :     147
        Spilled       :      13
        
    Routine stack
        Variables     :    5680 bytes*
            Reads     :      28 [6.35e+01 ~ 1.5%]
            Writes    :      77 [1.75e+02 ~ 4.1%]
        Spills        :      64 bytes*
            Reads     :      11 [1.99e+01 ~ 0.5%]
            Writes    :       9 [8.98e+00 ~ 0.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::READ_FEBECOP_BEAM

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::READ_FEBECOP_BEAM) [6/20=30.0%] comm_ptsrc_comp_mod.f90(659,14)
  -> EXTERN: (677,13) ANG2PIX_RING
  -> EXTERN: (680,8) for_write_int_lis
  -> EXTERN: (681,12) for_trim
  -> EXTERN: (681,17) _alloca
  -> EXTERN: (681,24) __getsp_inlined
  -> EXTERN: (681,24) __resetsp_inlined
  -> EXTERN: (681,24) for_cpstr
  -> EXTERN: (681,35) for_concat
  -> EXTERN: (681,35) __getsp_inlined
  -> EXTERN: (681,35) __resetsp_inlined
  -> EXTERN: (681,43) for_trim
  -> EXTERN: (681,48) _alloca
  -> EXTERN: (681,61) for_trim
  -> EXTERN: (681,66) for_adjustl
  -> EXTERN: (682,13) OPEN_HDF_FILE
  -> EXTERN: (683,13) __getsp_inlined
  -> EXTERN: (683,13) GET_SIZE_HDF
  -> EXTERN: (683,13) __resetsp_inlined
  -> EXTERN: (683,32) for_trim
  -> EXTERN: (683,37) for_adjustl
  -> EXTERN: (683,52) _alloca
  -> EXTERN: (683,52) for_concat
  -> EXTERN: (687,8) for_check_mult_overflow64
  -> EXTERN: (687,8) for_alloc_allocatable
  -> EXTERN: (687,8) for_check_mult_overflow64
  -> EXTERN: (687,8) for_alloc_allocatable
  -> EXTERN: (687,8) for_check_mult_overflow64
  -> EXTERN: (687,8) for_alloc_allocatable
  -> EXTERN: (687,8) for_check_mult_overflow64
  -> EXTERN: (687,8) for_alloc_allocatable
  -> EXTERN: (688,13) __getsp_inlined
  -> EXTERN: (688,13) READ_HDF_1D_INT
  -> EXTERN: (688,13) __resetsp_inlined
  -> EXTERN: (688,28) for_trim
  -> EXTERN: (688,33) for_adjustl
  -> EXTERN: (688,48) _alloca
  -> EXTERN: (688,48) for_concat
  -> EXTERN: (689,13) __getsp_inlined
  -> EXTERN: (689,13) READ_HDF_2D_DP
  -> EXTERN: (689,13) __resetsp_inlined
  -> EXTERN: (689,28) for_trim
  -> EXTERN: (689,33) for_adjustl
  -> EXTERN: (689,48) _alloca
  -> EXTERN: (689,48) for_concat
  -> EXTERN: (690,13) CLOSE_HDF_FILE
  -> EXTERN: (693,13) mpi_bcast_
  -> EXTERN: (695,13) mpi_bcast_
  -> EXTERN: (696,8) for_alloc_allocatable
  -> EXTERN: (696,8) for_check_mult_overflow64
  -> EXTERN: (696,8) for_alloc_allocatable
  -> EXTERN: (696,8) for_check_mult_overflow64
  -> EXTERN: (696,8) for_alloc_allocatable
  -> EXTERN: (696,8) for_check_mult_overflow64
  -> EXTERN: (696,8) for_alloc_allocatable
  -> EXTERN: (696,8) for_check_mult_overflow64
  -> EXTERN: (698,10) mpi_bcast_
  -> EXTERN: (699,10) mpi_bcast_
  -> EXTERN: (704,12) LOCATE_INT
  -> EXTERN: (707,12) LOCATE_INT
  -> EXTERN: (729,5) for_alloc_allocatable
  -> EXTERN: (729,5) for_check_mult_overflow64
  -> EXTERN: (729,5) for_alloc_allocatable
  -> EXTERN: (729,5) for_check_mult_overflow64
  -> EXTERN: (729,5) for_alloc_allocatable
  -> EXTERN: (729,5) for_check_mult_overflow64
  -> EXTERN: (730,5) for_realloc_lhs
  -> EXTERN: (736,5) for_dealloc_allocatable
  -> EXTERN: (736,5) for_dealloc_allocatable
  -> EXTERN: (736,5) for_dealloc_allocatable
  -> EXTERN: (736,5) for_dealloc_allocatable
  -> EXTERN: (738,3) for_dealloc_allocatable
  -> EXTERN: (738,3) for_dealloc_allocatable
  -> EXTERN: (738,3) for_dealloc_allocatable
  -> EXTERN: (738,3) for_dealloc_allocatable
  -> EXTERN: (738,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(705,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(711,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(715,14)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <MYBEAM(t%NP,:)>, stride is unknown to compiler
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <B(i,:)>, stride is unknown to compiler
      remark #15305: vectorization support: vector length 2
      remark #15452: unmasked strided loads: 1 
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 4.000 
      remark #15478: estimated potential speedup: 1.000 
      remark #15488: --- end vector cost summary ---
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(715,14)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(730,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between t(:,:) (730:5) and t(:,:) (730:5)
   remark #17106: parallel dependence: assumed OUTPUT dependence between t(:,:) (730:5) and t(:,:) (730:5)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(730,5)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between t(:,:) (730:5) and t(:,:) (730:5)
      remark #17106: parallel dependence: assumed OUTPUT dependence between t(:,:) (730:5) and t(:,:) (730:5)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(730,5)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(730,5)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference t(:,:) has aligned access
         remark #15388: vectorization support: reference MYPIX(:,:) has aligned access
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 4.667
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 0.750 
         remark #15478: estimated potential speedup: 2.130 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(730,5)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(730,5)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=24
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(733,10)
   remark #17109: LOOP WAS AUTO-PARALLELIZED
   remark #17101: parallel loop shared={ } private={ } firstprivate={ ? ? ? ? ? ? ? ? ? ? ? B MYBEAM i } lastprivate={ } firstlastprivate={ } reduction={ }
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,42)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,42)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(732,42) ]
      remark #15388: vectorization support: reference B(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.426
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 8.500 
      remark #15478: estimated potential speedup: 1.040 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,42)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,8)
      remark #15388: vectorization support: reference t(:,i) has aligned access
      remark #15388: vectorization support: reference MYBEAM(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.114
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 30 
      remark #15477: vector cost: 17.500 
      remark #15478: estimated potential speedup: 1.690 
      remark #15486: divides: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,8)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,8)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference t(:,i) has aligned access
      remark #15389: vectorization support: reference MYBEAM(:,i) has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.375
      remark #15301: REMAINDER LOOP WAS VECTORIZED
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,8)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(733,23)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(733,23)
      remark #25045: Fused Loops: ( 733 733 )

      remark #15388: vectorization support: reference B(:,i) has aligned access
      remark #15388: vectorization support: reference B(:,i) has aligned access   [ comm_ptsrc_comp_mod.f90(733,35) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.545
      remark #15301: FUSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 14 
      remark #15477: vector cost: 11.000 
      remark #15478: estimated potential speedup: 1.250 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(733,35)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(733,35) ]
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(733,23)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(733,10)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,42)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,42)
      remark #17107: loop was not parallelized: inner loop
      remark #15388: vectorization support: reference B(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.426
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 8.500 
      remark #15478: estimated potential speedup: 1.040 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,42)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,8)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,8)
      remark #17107: loop was not parallelized: inner loop
      remark #15388: vectorization support: reference t(:,i) has aligned access
      remark #15388: vectorization support: reference MYBEAM(:,i) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.114
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 30 
      remark #15477: vector cost: 17.500 
      remark #15478: estimated potential speedup: 1.690 
      remark #15486: divides: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,8)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,8)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference t(:,i) has aligned access
      remark #15389: vectorization support: reference MYBEAM(:,i) has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.375
      remark #15301: REMAINDER LOOP WAS VECTORIZED
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(732,8)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(733,23)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(733,23)
      remark #17107: loop was not parallelized: inner loop
      remark #15388: vectorization support: reference B(:,i) has aligned access
      remark #15388: vectorization support: reference B(:,i) has aligned access   [ comm_ptsrc_comp_mod.f90(733,35) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.545
      remark #15301: FUSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 14 
      remark #15477: vector cost: 11.000 
      remark #15478: estimated potential speedup: 1.250 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(733,23)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(673,50):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(672,53):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(671,50):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(672,50):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(670,50):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(730,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(730,5):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(730,5):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(659,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_read_febecop_beam_] comm_ptsrc_comp_mod.f90:659

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   24[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm9]
        
    Routine temporaries
        Total         :    1544
            Global    :     304
            Local     :    1240
        Regenerable   :     315
        Spilled       :      69
        
    Routine stack
        Variables     :    3376 bytes*
            Reads     :      77 [6.55e+01 ~ 0.7%]
            Writes    :     200 [1.16e+02 ~ 1.2%]
        Spills        :     592 bytes*
            Reads     :     113 [2.53e+02 ~ 2.6%]
            Writes    :      85 [9.46e+01 ~ 1.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::UPDATEF

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::UPDATEF) [7/20=35.0%] comm_ptsrc_comp_mod.f90(181,14)
  -> EXTERN: (191,11) for_realloc_lhs
  -> INDIRECT-: (196,18)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)(comm_ptsrc_comp_mod_mp_updatef_$SELF_V$4061.0.3->QNCAtemplate.dim31_dv_template.addr_a0_V$4097.0.3)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_updatef_$I_V$4084.0.3)), l:((comm_ptsrc_comp_mod_mp_updatef_$SELF_V$4061.0.3->QNCAtemplate.dim31_dv_template.addr_a0_V$4097.0.3)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (205,24)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)(comm_ptsrc_comp_mod_mp_updatef_$SELF_V$4061.0.3->QNCAtemplate.dim31_dv_template.addr_a0_V$4097.0.3)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_updatef_$I_V$4084.0.3)), l:((comm_ptsrc_comp_mod_mp_updatef_$SELF_V$4061.0.3->QNCAtemplate.dim31_dv_template.addr_a0_V$4097.0.3)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (213,24)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)(comm_ptsrc_comp_mod_mp_updatef_$SELF_V$4061.0.3->QNCAtemplate.dim31_dv_template.addr_a0_V$4097.0.3)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_updatef_$I_V$4084.0.3)), l:((comm_ptsrc_comp_mod_mp_updatef_$SELF_V$4061.0.3->QNCAtemplate.dim31_dv_template.addr_a0_V$4097.0.3)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(189,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between beta%407c%407c(0) (191:11) and self (213:24)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(191,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between at (191:11) and at (191:11)
      remark #17106: parallel dependence: assumed FLOW dependence between at (191:11) and at (191:11)
      remark #17106: parallel dependence: assumed ANTI dependence between at (191:11) and at (191:11)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(191,11)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(191,11)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (191:11) has aligned access
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <beta(:,:,j)>, stride is unknown to compiler
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 2.200
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 1.570 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(191,11)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(193,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between self (196:18) and self (213:24)
      remark #17106: parallel dependence: assumed FLOW dependence between self (213:24) and self (196:18)
      remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(196,18) ]
      remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(205,24) ]
      remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(213,24) ]
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between self (196:18) and self (213:24)
      remark #15346: vector dependence: assumed FLOW dependence between self (213:24) and self (196:18)
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(181,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_updatef_] comm_ptsrc_comp_mod.f90:181

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :     199
            Global    :      57
            Local     :     142
        Regenerable   :      13
        Spilled       :      18
        
    Routine stack
        Variables     :     312 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :      38 [3.33e+02 ~ 8.5%]
        Spills        :     144 bytes*
            Reads     :      33 [1.71e+02 ~ 4.4%]
            Writes    :      22 [3.39e+01 ~ 0.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::EVALSED

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::EVALSED) [8/20=40.0%] comm_ptsrc_comp_mod.f90(221,12)
  -> EXTERN: (230,18) memmove
  -> EXTERN: (230,18) _alloca
  -> EXTERN: (230,18) for_trim
  -> EXTERN: (231,11) for_cpstr
  -> EXTERN: (234,34) pow
  -> EXTERN: (235,11) for_cpstr
  -> EXTERN: (237,19) exp
  -> EXTERN: (237,45) exp
  -> EXTERN: (237,79) pow
  -> EXTERN: (238,11) for_cpstr
  -> EXTERN: (240,13) REPORT_ERROR
  -> EXTERN: (240,13) __resetsp_inlined
  -> EXTERN: (240,13) __getsp_inlined


    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(230,18):remark #34014: optimization advice for memmove: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(230,18):remark #34026: call to memmove implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(221,12):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_evalsed_] comm_ptsrc_comp_mod.f90:221

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rsi rdi r8 r12-r15 zmm0-zmm3]
        
    Routine temporaries
        Total         :     102
            Global    :      33
            Local     :      69
        Regenerable   :      25
        Spilled       :      12
        
    Routine stack
        Variables     :     512 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      56 bytes*
            Reads     :       8 [2.51e+00 ~ 3.5%]
            Writes    :       7 [2.26e+00 ~ 3.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::EVALPTSRCBAND

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::EVALPTSRCBAND) [9/20=45.0%] comm_ptsrc_comp_mod.f90(245,12)
  -> EXTERN: (245,12) for_deallocate
  -> EXTERN: (245,46) for_deallocate
  -> EXTERN: (259,12) for_check_mult_overflow64
  -> EXTERN: (259,12) for_alloc_allocatable
  -> EXTERN: (261,5) for_alloc_allocatable
  -> EXTERN: (261,5) for_check_mult_overflow64
  -> EXTERN: (264,11) for_realloc_lhs
  -> EXTERN: (266,11) for_realloc_lhs
  -> EXTERN: (269,10) mpi_bcast_
  -> INDIRECT-: (276,15)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_evalptsrcband_$SELF_V$419a.0.5 + 56(SI64)))))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (286,25) for_dealloc_allocatable
  -> EXTERN: (288,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(264,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(264,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(264,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference AMP(:,:) has aligned access
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <amp_in(:,:)>, stride is unknown to compiler
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 2.000
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 2.500 
      remark #15478: estimated potential speedup: 1.570 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(264,11)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(266,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,:) (266:11) and AMP(:,:) (266:11)
   remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,:) (266:11) and AMP(:,:) (266:11)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(266,11)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,:) (266:11) and AMP(:,:) (266:11)
      remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,:) (266:11) and AMP(:,:) (266:11)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(266,11)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(266,11)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference AMP(:,:) has aligned access
         remark #15388: vectorization support: reference self(:,:) has aligned access
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 4.667
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 1.290 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(266,11)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(266,11)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(272,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(272,5)
      remark #25408: memset generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between evalptsrcband(:,:) (272:5) and evalptsrcband(:,:) (272:5)
      remark #17106: parallel dependence: assumed OUTPUT dependence between evalptsrcband(:,:) (272:5) and evalptsrcband(:,:) (272:5)
      remark #15542: loop was not vectorized: inner loop was already vectorized
      remark #25015: Estimate of max trip count of loop=1

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(272,5)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15389: vectorization support: reference evalptsrcband(:,:) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 1.450 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(272,5)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(274,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(274,8)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(279,11)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed ANTI dependence between evalptsrcband(p,j) (281:14) and evalptsrcband(p,j) (281:14)
         remark #15346: vector dependence: assumed FLOW dependence between evalptsrcband(p,j) (281:14) and evalptsrcband(p,j) (281:14)
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(256,46):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(272,5):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(272,5):remark #34026: call to memset implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(266,11):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(266,11):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(266,11):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(245,12):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_evalptsrcband_] comm_ptsrc_comp_mod.f90:245

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :     457
            Global    :     105
            Local     :     352
        Regenerable   :      41
        Spilled       :      32
        
    Routine stack
        Variables     :     224 bytes*
            Reads     :      24 [1.86e+02 ~ 4.3%]
            Writes    :      37 [6.29e+01 ~ 1.4%]
        Spills        :     216 bytes*
            Reads     :      67 [1.95e+02 ~ 4.5%]
            Writes    :      41 [4.48e+01 ~ 1.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::PROJECTPTSRCBAND

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::PROJECTPTSRCBAND) [10/20=50.0%] comm_ptsrc_comp_mod.f90(291,12)
  -> EXTERN: (291,12) for_deallocate
  -> EXTERN: (304,12) for_check_mult_overflow64
  -> EXTERN: (304,12) for_alloc_allocatable
  -> EXTERN: (307,5) for_alloc_allocatable
  -> EXTERN: (307,5) for_check_mult_overflow64
  -> EXTERN: (307,5) for_alloc_allocatable
  -> EXTERN: (307,5) for_check_mult_overflow64
  -> INDIRECT-: (318,17)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_projectptsrcband_$SELF_V$4281.0.6 + 56(SI64)))))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (325,10) mpi_reduce_
  -> EXTERN: (326,25) for_realloc_lhs
  -> EXTERN: (326,25) for_dealloc_allocatable
  -> EXTERN: (328,5) for_dealloc_allocatable
  -> EXTERN: (328,5) for_dealloc_allocatable
  -> EXTERN: (330,3) for_dealloc_allocatable
  -> EXTERN: (330,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(308,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(308,5)
      remark #25408: memset generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,:) (308:5) and AMP(:,:) (308:5)
      remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,:) (308:5) and AMP(:,:) (308:5)
      remark #15542: loop was not vectorized: inner loop was already vectorized
      remark #25015: Estimate of max trip count of loop=1

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(308,5)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15389: vectorization support: reference AMP(:,:) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 1.450 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(308,5)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(314,57)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(310,8)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(312,11)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(312,11)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference self(i,band,q,j) has aligned access   [ comm_ptsrc_comp_mod.f90(314,26) ]
         remark #15389: vectorization support: reference self(i,band,q,1) has unaligned access   [ comm_ptsrc_comp_mod.f90(313,14) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15328: vectorization support: irregularly indexed load was emulated for the variable <map(self(i,band,q,1),j)>, part of index is read from memory   [ comm_ptsrc_comp_mod.f90(314,57) ]
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.635
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15462: unmasked indexed (or gather) loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 11 
         remark #15477: vector cost: 6.500 
         remark #15478: estimated potential speedup: 1.640 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(312,11)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(326,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between projectptsrcband(:,:) (326:25) and projectptsrcband(:,:) (326:25)
   remark #17106: parallel dependence: assumed OUTPUT dependence between projectptsrcband(:,:) (326:25) and projectptsrcband(:,:) (326:25)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(326,25)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between projectptsrcband(:,:) (326:25) and projectptsrcband(:,:) (326:25)
      remark #17106: parallel dependence: assumed OUTPUT dependence between projectptsrcband(:,:) (326:25) and projectptsrcband(:,:) (326:25)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(326,25)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(326,25)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference projectptsrcband(:,:) has aligned access
         remark #15388: vectorization support: reference AMP2(:,:) has aligned access
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 4.667
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 1.290 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(326,25)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(326,25)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(301,51):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(301,46):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(308,5):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(308,5):remark #34026: call to memset implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(326,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(326,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(326,25):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(291,12):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_projectptsrcband_] comm_ptsrc_comp_mod.f90:291

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   22[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm7]
        
    Routine temporaries
        Total         :     517
            Global    :     104
            Local     :     413
        Regenerable   :      47
        Spilled       :      25
        
    Routine stack
        Variables     :     232 bytes*
            Reads     :      31 [1.37e+02 ~ 1.2%]
            Writes    :      43 [8.05e+01 ~ 0.7%]
        Spills        :     160 bytes*
            Reads     :      40 [2.66e+02 ~ 2.3%]
            Writes    :      25 [6.03e+01 ~ 0.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::UPDATEPTSRCPRECOND

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::UPDATEPTSRCPRECOND) [11/20=55.0%] comm_ptsrc_comp_mod.f90(1137,14)
  -> (1141,10) COMM_PTSRC_COMP_MOD::INITPTSRCPRECOND (isz = 3681) (sz = 3686)
     [[ Inlining would exceed -inline-max-total-size value (3681>2000) <1>]]


    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(1137,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_updateptsrcprecond_] comm_ptsrc_comp_mod.f90:1137

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::APPLYPTSRCPRECOND

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::APPLYPTSRCPRECOND) [12/20=60.0%] comm_ptsrc_comp_mod.f90(1146,14)
  -> EXTERN: (1160,5) for_alloc_allocatable
  -> EXTERN: (1160,5) for_check_mult_overflow64
  -> EXTERN: (1166,21) strcmp
  -> INDIRECT-: (1172,16)  (*((P64*) comm_ptsrc_comp_mod_mp_applyptsrcprecond_$C$73_V$53fb.0.15))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1175,13) CR_EXTRACT_COMP_2D
  -> INDIRECT-: (1180,13)  (*((P64*) comm_ptsrc_comp_mod_mp_applyptsrcprecond_$C$73_V$53fb.0.15))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1181,8) for_dealloc_allocatable
  -> EXTERN: (1186,8) __resetsp_inlined
  -> EXTERN: (1186,8) __getsp_inlined
  -> EXTERN: (1186,17) _alloca
  -> EXTERN: (1194,21) strcmp
  -> INDIRECT-: (1200,16)  (*((P64*) comm_ptsrc_comp_mod_mp_applyptsrcprecond_$C$73_V$53fb.0.15))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1203,8) for_alloc_allocatable
  -> EXTERN: (1203,8) for_check_mult_overflow64
  -> EXTERN: (1207,13) CR_INSERT_COMP_2D
  -> INDIRECT-: (1209,13)  (*((P64*) comm_ptsrc_comp_mod_mp_applyptsrcprecond_$C$73_V$53fb.0.15))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1210,8) for_dealloc_allocatable
  -> EXTERN: (1213,5) for_dealloc_allocatable
  -> EXTERN: (1215,3) for_dealloc_allocatable
  -> EXTERN: (1215,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(1161,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1161,5)
      remark #25408: memset generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between Y(:,:) (1161:5) and Y(:,:) (1161:5)
      remark #17106: parallel dependence: assumed OUTPUT dependence between Y(:,:) (1161:5) and Y(:,:) (1161:5)
      remark #15542: loop was not vectorized: inner loop was already vectorized
      remark #25015: Estimate of max trip count of loop=1

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1161,5)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15389: vectorization support: reference Y(:,:) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 1.450 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1161,5)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1194,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1166,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1177,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between Y(:,k) (1177:11) and Y(:,k) (1177:11)
      remark #17106: parallel dependence: assumed OUTPUT dependence between Y(:,k) (1177:11) and Y(:,k) (1177:11)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1177,11)
         remark #25399: memcopy generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between Y(:,k) (1177:11) and Y(:,k) (1177:11)
         remark #17106: parallel dependence: assumed OUTPUT dependence between Y(:,k) (1177:11) and Y(:,k) (1177:11)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1177,11)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1177,11)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference Y(:,k) has aligned access
            remark #15388: vectorization support: reference AMP(:,k) has aligned access
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 4.667
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 1.290 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1177,11)
         <Alternate Alignment Vectorized Loop>
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1177,11)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1185,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between at (1186:17) and at (1186:8)
   remark #17106: parallel dependence: assumed ANTI dependence between at (1186:8) and at (1186:17)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1186,17)
      remark #25408: memset generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (1186:17) and at (1186:17)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (1186:17) and at (1186:17)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1186,17)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (1186:17) has aligned access
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 2
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 2.660 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1186,17)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1186,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (1186:17) and at (1186:17)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (1186:17) and at (1186:17)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1186,17)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (1186:17) has aligned access
         remark #15388: vectorization support: reference at (1186:17) has aligned access
         remark #15389: vectorization support: reference p_cr(1,j,:,:) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.139
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 4.500 
         remark #15478: estimated potential speedup: 1.960 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1186,17)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference at (1186:17) has aligned access
         remark #15388: vectorization support: reference at (1186:17) has aligned access
         remark #15389: vectorization support: reference p_cr(1,j,:,:) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.000
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1186,8)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between Y(:,j) (1186:8) and Y(:,j) (1186:8)
      remark #17106: parallel dependence: assumed OUTPUT dependence between Y(:,j) (1186:8) and Y(:,j) (1186:8)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1186,8)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference Y(:,j) has aligned access
         remark #15388: vectorization support: reference at (1186:8) has aligned access
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.333
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 2.180 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1186,8)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1186,8)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1194,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1194,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1204,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,k) (1205:11) and AMP(:,k) (1205:11)
      remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,k) (1205:11) and AMP(:,k) (1205:11)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1205,11)
         remark #25399: memcopy generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,k) (1205:11) and AMP(:,k) (1205:11)
         remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,k) (1205:11) and AMP(:,k) (1205:11)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1205,11)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1205,11)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference AMP(:,k) has aligned access
            remark #15388: vectorization support: reference Y(:,k) has aligned access
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 4.667
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 1.290 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1205,11)
         <Alternate Alignment Vectorized Loop>
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1205,11)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(1153,46):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1152,46):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1161,5):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1161,5):remark #34026: call to memset implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1163,5):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(1163,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (8, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1186,17):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1186,17):remark #34026: call to memset implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1186,8):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1186,8):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1186,8):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1191,5):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(1191,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (8, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1194,21):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1196,11):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1166,21):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1168,11):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1177,11):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1177,11):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1177,11):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1205,11):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1205,11):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1205,11):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1146,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_applyptsrcprecond_] comm_ptsrc_comp_mod.f90:1146

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :     592
            Global    :     162
            Local     :     430
        Regenerable   :      66
        Spilled       :      54
        
    Routine stack
        Variables     :     976 bytes*
            Reads     :     103 [2.88e+00 ~ 1.7%]
            Writes    :     188 [1.45e+01 ~ 8.4%]
        Spills        :     384 bytes*
            Reads     :      97 [1.61e+00 ~ 0.9%]
            Writes    :      69 [8.17e-01 ~ 0.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::GETSCALE

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::GETSCALE) [13/20=65.0%] comm_ptsrc_comp_mod.f90(1217,12)
  -> EXTERN: (1223,9) for_trim
  -> EXTERN: (1223,25) for_cpstr
  -> EXTERN: (1223,41) for_trim
  -> EXTERN: (1223,57) for_cpstr


    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(1217,12):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_getscale_] comm_ptsrc_comp_mod.f90:1217

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   13[ rax rdx rcx rbx rsi rdi r8 r12-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :      73
            Global    :      22
            Local     :      51
        Regenerable   :      20
        Spilled       :       6
        
    Routine stack
        Variables     :    1024 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       8 bytes*
            Reads     :       1 [1.00e+00 ~ 1.3%]
            Writes    :       1 [1.00e+00 ~ 1.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::SAMPLEPTSRCSPECIND

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::SAMPLEPTSRCSPECIND) [14/20=70.0%] comm_ptsrc_comp_mod.f90(1277,14)
  -> EXTERN: (1298,9) for_trim
  -> EXTERN: (1298,25) for_cpstr
  -> EXTERN: (1299,8) for_check_mult_overflow64
  -> EXTERN: (1299,8) for_alloc_allocatable
  -> INDIRECT-: (1306,22)  (*((P64*) comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$C$79_V$58d9.0.18))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1308,27) strcmp
  -> EXTERN: (1316,17) for_realloc_lhs
  -> EXTERN: (1318,19) mpi_bcast_
  -> EXTERN: (1319,19) mpi_bcast_
  -> INDIRECT-: (1323,21)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18 + 56(SI64)))))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1323,44)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:((comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1332,17) for_alloc_allocatable
  -> EXTERN: (1332,17) for_check_mult_overflow64
  -> EXTERN: (1336,22) POWELL
  -> EXTERN: (1338,17) for_realloc_lhs
  -> EXTERN: (1345,17) for_dealloc_allocatable
  -> EXTERN: (1349,22) mpi_bcast_
  -> EXTERN: (1352,25) mpi_bcast_
  -> (1354,31) COMM_PTSRC_COMP_MOD::LNL_PTSRC_MULTI (isz = 967) (sz = 972)
     [[ Inlining inhibited by overrideable criterion  <4>]]
  -> EXTERN: (1362,19) mpi_bcast_
  -> EXTERN: (1363,19) mpi_bcast_
  -> INDIRECT-: (1370,21)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18 + 56(SI64)))))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1370,44)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:((comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1375,67)  (*((P64*) *((P64*) (&((COMM_DATA_SET$N$29_V$1039 *)comm_data_mod_mp_data__V$3758)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:comm_data_mod_mp_data__V$3761[0(SI32), l:0(SI64)]] + 56(SI64)))))[5(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1381,19) mpi_reduce_
  -> EXTERN: (1382,19) mpi_reduce_
  -> EXTERN: (1384,55) for_write_seq_lis_xmit
  -> EXTERN: (1384,55) for_write_seq_lis_xmit
  -> EXTERN: (1384,55) for_write_seq_lis_xmit
  -> EXTERN: (1384,55) for_write_seq_lis
  -> EXTERN: (1387,8) for_dealloc_allocatable
  -> INDIRECT-: (1390,13)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18 + 56(SI64)))))[15(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1399,5) for_alloc_allocatable
  -> EXTERN: (1399,5) for_check_mult_overflow64
  -> EXTERN: (1399,5) for_alloc_allocatable
  -> EXTERN: (1399,5) for_check_mult_overflow64
  -> EXTERN: (1400,25) for_realloc_lhs
  -> EXTERN: (1401,10) mpi_bcast_
  -> EXTERN: (1461,5) for_alloc_allocatable
  -> EXTERN: (1461,5) for_check_mult_overflow64
  -> EXTERN: (1461,5) for_alloc_allocatable
  -> EXTERN: (1461,5) for_check_mult_overflow64
  -> EXTERN: (1461,5) for_alloc_allocatable
  -> EXTERN: (1461,5) for_check_mult_overflow64
  -> EXTERN: (1461,5) for_alloc_allocatable
  -> EXTERN: (1461,5) for_check_mult_overflow64
  -> EXTERN: (1461,5) for_alloc_allocatable
  -> EXTERN: (1461,5) for_check_mult_overflow64
  -> EXTERN: (1464,28) for_write_seq_lis
  -> EXTERN: (1464,28) for_write_seq_lis_xmit
  -> EXTERN: (1471,16) wall_time_
  -> EXTERN: (1475,17) for_realloc_lhs
  -> INDIRECT-: (1482,32)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:((comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1483,32)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18 + 56(SI64)))))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1507,37)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:((comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1510,30)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18 + 56(SI64)))))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1517,36)  (*((P64*) *((P64*) (&((COMM_DATA_SET$N$29_V$1039 *)comm_data_mod_mp_data__V$3758)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:comm_data_mod_mp_data__V$3761[0(SI32), l:0(SI64)]] + 56(SI64)))))[5(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1524,25) mpi_reduce_
  -> EXTERN: (1554,25) mpi_bcast_
  -> EXTERN: (1555,25) mpi_bcast_
  -> EXTERN: (1556,25) mpi_bcast_
  -> EXTERN: (1564,20) __resetsp_inlined
  -> EXTERN: (1564,20) __getsp_inlined
  -> EXTERN: (1564,31) SAMPLE_INVSAMP
  -> EXTERN: (1564,31) _alloca
  -> EXTERN: (1565,52) for_trim
  -> EXTERN: (1565,67) for_cpstr
  -> EXTERN: (1568,20) for_realloc_lhs
  -> EXTERN: (1568,28) exp
  -> EXTERN: (1569,20) for_realloc_lhs
  -> EXTERN: (1586,22) mpi_bcast_
  -> INDIRECT-: (1594,24)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18 + 56(SI64)))))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1594,47)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:((comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1620,14) for_realloc_lhs
  -> INDIRECT-: (1625,21)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18 + 56(SI64)))))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1625,44)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:((comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1630,56)  (*((P64*) *((P64*) (&((COMM_DATA_SET$N$29_V$1039 *)comm_data_mod_mp_data__V$3758)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:comm_data_mod_mp_data__V$3761[0(SI32), l:0(SI64)]] + 56(SI64)))))[5(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1637,19) mpi_reduce_
  -> EXTERN: (1638,19) mpi_reduce_
  -> EXTERN: (1655,21) for_trim
  -> EXTERN: (1655,37) for_cpstr
  -> EXTERN: (1659,44) RAND_GAUSS
  -> EXTERN: (1662,37) RAND_TRUNC_GAUSS
  -> EXTERN: (1669,19) mpi_bcast_
  -> INDIRECT-: (1677,21)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18 + 56(SI64)))))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1677,44)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:((comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18->QNCAtemplate.dim31_dv_template.addr_a0_V$59aa.0.18)->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1684,67)  (*((P64*) *((P64*) (&((COMM_DATA_SET$N$29_V$1039 *)comm_data_mod_mp_data__V$3758)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$L_V$58f7.0.18)), l:comm_data_mod_mp_data__V$3761[0(SI32), l:0(SI64)]] + 56(SI64)))))[5(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1690,19) mpi_reduce_
  -> EXTERN: (1691,19) mpi_reduce_
  -> EXTERN: (1696,54) for_write_seq_lis_xmit
  -> EXTERN: (1696,54) _alloca
  -> EXTERN: (1696,54) for_write_seq_lis_xmit
  -> EXTERN: (1696,54) for_write_seq_lis_xmit
  -> EXTERN: (1696,54) for_write_seq_lis
  -> EXTERN: (1696,54) __getsp_inlined
  -> EXTERN: (1696,54) __resetsp_inlined
  -> INDIRECT-: (1715,10)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_sampleptsrcspecind_$SELF_V$58b3.0.18 + 56(SI64)))))[15(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1720,5) for_dealloc_allocatable
  -> EXTERN: (1720,5) for_dealloc_allocatable
  -> EXTERN: (1720,5) for_dealloc_allocatable
  -> EXTERN: (1720,5) for_dealloc_allocatable
  -> EXTERN: (1720,5) for_dealloc_allocatable
  -> EXTERN: (1720,5) for_dealloc_allocatable
  -> EXTERN: (1720,5) for_dealloc_allocatable
  -> EXTERN: (1722,3) for_dealloc_allocatable
  -> EXTERN: (1722,3) for_dealloc_allocatable
  -> EXTERN: (1722,3) for_dealloc_allocatable
  -> EXTERN: (1722,3) for_dealloc_allocatable
  -> EXTERN: (1722,3) for_dealloc_allocatable
  -> EXTERN: (1722,3) for_dealloc_allocatable
  -> EXTERN: (1722,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(1308,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1305,14)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1308,27)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1316,17)
         remark #25399: memcopy generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between THETA(:) (1316:17) and THETA(:) (1316:17)
         remark #17106: parallel dependence: assumed OUTPUT dependence between THETA(:) (1316:17) and THETA(:) (1316:17)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1316,17)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference THETA(:) has aligned access
            remark #15389: vectorization support: reference at (1316:17) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 1.770 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1316,17)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1321,14)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1324,17)
            remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(1325,20) ]
            remark #15344: loop was not vectorized: vector dependence prevents vectorization
            remark #15346: vector dependence: assumed ANTI dependence between at (1326:20) and data_(l,pix,p) (1326:20)
            remark #15346: vector dependence: assumed FLOW dependence between data_(l,pix,p) (1326:20) and at (1326:20)
         LOOP END
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1335,17)
         remark #25399: memcopy generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between X(:) (1335:17) and X(:) (1335:17)
         remark #17106: parallel dependence: assumed OUTPUT dependence between X(:) (1335:17) and X(:) (1335:17)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1335,17)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference X(:) has aligned access
            remark #15389: vectorization support: reference at (1335:17) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 0.500
            remark #15300: LOOP WAS VECTORIZED
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 3.000 
            remark #15478: estimated potential speedup: 1.170 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1335,17)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1335,17)
         <Peeled loop for vectorization>
            remark #25436: completely unrolled by 1  
         LOOP END
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1338,17)
         remark #25399: memcopy generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between THETA(:) (1338:17) and THETA(:) (1338:17)
         remark #17106: parallel dependence: assumed OUTPUT dependence between THETA(:) (1338:17) and THETA(:) (1338:17)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1338,17)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference THETA(:) has aligned access
            remark #15389: vectorization support: reference X(:) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 1.770 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1338,17)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1339,17)
      <Distributed chunk1>
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed ANTI dependence between c_lnl(1,l) (1340:51) and THETA(l) (1341:27)
         remark #17106: parallel dependence: assumed FLOW dependence between THETA(l) (1341:27) and c_lnl(1,l) (1340:51)
         remark #25426: Loop Distributed (2 way) 
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.000
         remark #15301: PARTIAL LOOP WAS VECTORIZED
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 1 
         remark #15477: vector cost: 0.750 
         remark #15478: estimated potential speedup: 1.310 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1339,17)
      <Remainder loop for vectorization, Distributed chunk1>
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1339,17)
      <Distributed chunk2>
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed ANTI dependence between c_lnl(1,l) (1340:51) and THETA(l) (1341:27)
         remark #15346: vector dependence: assumed FLOW dependence between THETA(l) (1341:27) and c_lnl(1,l) (1340:51)
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1344,17)
         remark #25399: memcopy generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between at (1344:17) and at (1344:17)
         remark #17106: parallel dependence: assumed OUTPUT dependence between at (1344:17) and at (1344:17)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1344,17)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference at (1344:17) has aligned access
            remark #15388: vectorization support: reference THETA(:) has aligned access
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.667
            remark #15300: LOOP WAS VECTORIZED
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.080 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1344,17)
         <Alternate Alignment Vectorized Loop>
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1344,17)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1330,28)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1364,14)
         remark #25399: memcopy generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between at (1364:14) and at (1364:14)
         remark #17106: parallel dependence: assumed OUTPUT dependence between at (1364:14) and at (1364:14)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1364,14)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference at (1364:14) has aligned access
            remark #15388: vectorization support: reference THETA(:) has aligned access
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.667
            remark #15300: LOOP WAS VECTORIZED
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.080 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1364,14)
         <Alternate Alignment Vectorized Loop>
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1364,14)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1369,14)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1371,17)
            remark #17104: loop was not parallelized: existence of parallel dependence
            remark #17106: parallel dependence: assumed ANTI dependence between self%COMM_PTSRC_COMP (1372:20) and data_(l) (1375:67)
            remark #17106: parallel dependence: assumed FLOW dependence between data_(l) (1375:67) and self%COMM_PTSRC_COMP (1372:20)
            remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(1375,67) ]
            remark #15344: loop was not vectorized: vector dependence prevents vectorization
            remark #15346: vector dependence: assumed ANTI dependence between self%COMM_PTSRC_COMP (1372:20) and data_(l) (1375:67)
            remark #15346: vector dependence: assumed FLOW dependence between data_(l) (1375:67) and self%COMM_PTSRC_COMP (1372:20)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1400,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,:) (1400:25) and AMP(:,:) (1400:25)
   remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,:) (1400:25) and AMP(:,:) (1400:25)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1400,25)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,:) (1400:25) and AMP(:,:) (1400:25)
      remark #17106: parallel dependence: assumed OUTPUT dependence between AMP(:,:) (1400:25) and AMP(:,:) (1400:25)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1400,25)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1400,25)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference AMP(:,:) has aligned access
         remark #15388: vectorization support: reference self(:,:) has aligned access
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 4.667
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 1.290 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1400,25)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1400,25)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1462,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (1464:28) and at (1696:54)
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (1696:54) and at (1464:28)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1467,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between self (1468:50) and theta (1594:47)
      remark #17106: parallel dependence: assumed FLOW dependence between theta (1594:47) and self (1468:50)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1472,11)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1475,17)
            remark #17102: loop was not parallelized: not a parallelization candidate
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1475,17)
               remark #25399: memcopy generated
               remark #17104: loop was not parallelized: existence of parallel dependence
               remark #17106: parallel dependence: assumed OUTPUT dependence between THETA(:) (1475:17) and THETA(:) (1475:17)
               remark #17106: parallel dependence: assumed OUTPUT dependence between THETA(:) (1475:17) and THETA(:) (1475:17)
               remark #15542: loop was not vectorized: inner loop was already vectorized

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1475,17)
                  remark #17108: loop was not parallelized: insufficient computational work
                  remark #15388: vectorization support: reference THETA(:) has aligned access
                  remark #15389: vectorization support: reference at (1475:17) has unaligned access
                  remark #15381: vectorization support: unaligned access used inside loop body
                  remark #15305: vectorization support: vector length 2
                  remark #15309: vectorization support: normalized vectorization overhead 0.750
                  remark #15300: LOOP WAS VECTORIZED
                  remark #15449: unmasked aligned unit stride stores: 1 
                  remark #15450: unmasked unaligned unit stride loads: 1 
                  remark #15475: --- begin vector cost summary ---
                  remark #15476: scalar cost: 4 
                  remark #15477: vector cost: 2.000 
                  remark #15478: estimated potential speedup: 1.770 
                  remark #15488: --- end vector cost summary ---
                  remark #25015: Estimate of max trip count of loop=6
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1475,17)
               <Remainder loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=12
               LOOP END
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1480,17)
               remark #17102: loop was not parallelized: not a parallelization candidate
               remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1488,17)
               remark #17104: loop was not parallelized: existence of parallel dependence
               remark #17106: parallel dependence: assumed ANTI dependence between self (1491:23) and theta (1507:37)
               remark #17106: parallel dependence: assumed FLOW dependence between theta (1507:37) and self (1491:23)
               remark #15542: loop was not vectorized: inner loop was already vectorized

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1497,36)
               <Peeled loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=1
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1497,36)
                  remark #17108: loop was not parallelized: insufficient computational work
                  remark #15388: vectorization support: reference X(i) has aligned access   [ comm_ptsrc_comp_mod.f90(1497,23) ]
                  remark #15305: vectorization support: vector length 2
                  remark #15399: vectorization support: unroll factor set to 4
                  remark #15309: vectorization support: normalized vectorization overhead 0.341
                  remark #15300: LOOP WAS VECTORIZED
                  remark #15449: unmasked aligned unit stride stores: 1 
                  remark #15475: --- begin vector cost summary ---
                  remark #15476: scalar cost: 41 
                  remark #15477: vector cost: 5.500 
                  remark #15478: estimated potential speedup: 5.530 
                  remark #15487: type converts: 1 
                  remark #15488: --- end vector cost summary ---
                  remark #25015: Estimate of max trip count of loop=12
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1497,36)
               <Remainder loop for vectorization>
                  remark #15388: vectorization support: reference X(i) has aligned access   [ comm_ptsrc_comp_mod.f90(1497,23) ]
                  remark #15305: vectorization support: vector length 2
                  remark #15309: vectorization support: normalized vectorization overhead 1.154
                  remark #15301: REMAINDER LOOP WAS VECTORIZED
                  remark #25015: Estimate of max trip count of loop=50
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1497,36)
               <Remainder loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=101
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1500,20)
                  remark #25408: memset generated
                  remark #17104: loop was not parallelized: existence of parallel dependence
                  remark #17106: parallel dependence: assumed OUTPUT dependence between LNL(:) (1500:20) and LNL(:) (1500:20)
                  remark #17106: parallel dependence: assumed OUTPUT dependence between LNL(:) (1500:20) and LNL(:) (1500:20)
                  remark #15542: loop was not vectorized: inner loop was already vectorized
                  remark #25015: Estimate of max trip count of loop=1

                  LOOP BEGIN at comm_ptsrc_comp_mod.f90(1500,20)
                     remark #17108: loop was not parallelized: insufficient computational work
                     remark #15388: vectorization support: reference LNL(:) has aligned access
                     remark #15305: vectorization support: vector length 2
                     remark #15399: vectorization support: unroll factor set to 2
                     remark #15300: LOOP WAS VECTORIZED
                     remark #15449: unmasked aligned unit stride stores: 1 
                     remark #15475: --- begin vector cost summary ---
                     remark #15476: scalar cost: 4 
                     remark #15477: vector cost: 1.500 
                     remark #15478: estimated potential speedup: 2.660 
                     remark #15488: --- end vector cost summary ---
                     remark #25015: Estimate of max trip count of loop=3
                  LOOP END

                  LOOP BEGIN at comm_ptsrc_comp_mod.f90(1500,20)
                  <Remainder loop for vectorization>
                     remark #25015: Estimate of max trip count of loop=12
                  LOOP END
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1501,20)
                  remark #17104: loop was not parallelized: existence of parallel dependence
                  remark #17106: parallel dependence: assumed OUTPUT dependence between l (1502:23) and l (1502:23)
                  remark #17106: parallel dependence: assumed OUTPUT dependence between l (1502:23) and l (1502:23)
                  remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(1507,37) ]
                  remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(1510,30) ]
                  remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(1517,36) ]
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between l (1502:23) and l (1502:23)
                  remark #15346: vector dependence: assumed OUTPUT dependence between l (1502:23) and l (1502:23)
                  remark #25015: Estimate of max trip count of loop=101

                  LOOP BEGIN at comm_ptsrc_comp_mod.f90(1502,23)
                     remark #17102: loop was not parallelized: not a parallelization candidate
                     remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

                     LOOP BEGIN at comm_ptsrc_comp_mod.f90(1513,26)
                        remark #17104: loop was not parallelized: existence of parallel dependence
                        remark #17106: parallel dependence: assumed ANTI dependence between self%COMM_PTSRC_COMP (1514:29) and data_(l) (1517:36)
                        remark #17106: parallel dependence: assumed FLOW dependence between data_(l) (1517:36) and self%COMM_PTSRC_COMP (1514:29)
                        remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(1517,36) ]
                        remark #15344: loop was not vectorized: vector dependence prevents vectorization
                        remark #15346: vector dependence: assumed ANTI dependence between self%COMM_PTSRC_COMP (1514:29) and data_(l) (1517:36)
                        remark #15346: vector dependence: assumed FLOW dependence between data_(l) (1517:36) and self%COMM_PTSRC_COMP (1514:29)
                     LOOP END
                  LOOP END
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1529,26)
               <Peeled loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=1
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1529,26)
                  remark #17109: LOOP WAS AUTO-PARALLELIZED
                  remark #17101: parallel loop shared={ } private={ } firstprivate={ X P_TOT i counter j iter } lastprivate={ } firstlastprivate={ } reduction={ }
                  remark #15388: vectorization support: reference X(i) has aligned access   [ comm_ptsrc_comp_mod.f90(1529,57) ]
                  remark #15388: vectorization support: reference P_TOT(i) has aligned access
                  remark #15388: vectorization support: reference P_TOT(i) has aligned access   [ comm_ptsrc_comp_mod.f90(1529,37) ]
                  remark #15305: vectorization support: vector length 2
                  remark #15399: vectorization support: unroll factor set to 4
                  remark #15309: vectorization support: normalized vectorization overhead 0.096
                  remark #15300: LOOP WAS VECTORIZED
                  remark #15448: unmasked aligned unit stride loads: 2 
                  remark #15449: unmasked aligned unit stride stores: 1 
                  remark #15475: --- begin vector cost summary ---
                  remark #15476: scalar cost: 49 
                  remark #15477: vector cost: 26.000 
                  remark #15478: estimated potential speedup: 1.790 
                  remark #15486: divides: 1 
                  remark #15488: --- end vector cost summary ---
                  remark #25015: Estimate of max trip count of loop=12
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1529,26)
               <Alternate Alignment Vectorized Loop>
                  remark #25015: Estimate of max trip count of loop=12
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1529,26)
               <Remainder loop for vectorization>
                  remark #15389: vectorization support: reference X(i) has unaligned access   [ comm_ptsrc_comp_mod.f90(1529,57) ]
                  remark #15388: vectorization support: reference P_TOT(i) has aligned access
                  remark #15388: vectorization support: reference P_TOT(i) has aligned access   [ comm_ptsrc_comp_mod.f90(1529,37) ]
                  remark #15381: vectorization support: unaligned access used inside loop body
                  remark #15305: vectorization support: vector length 2
                  remark #15309: vectorization support: normalized vectorization overhead 0.322
                  remark #15301: REMAINDER LOOP WAS VECTORIZED
                  remark #25015: Estimate of max trip count of loop=50
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1529,26)
               <Remainder loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=101
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1533,31)
                  remark #17108: loop was not parallelized: insufficient computational work
                  remark #15388: vectorization support: reference P_TOT(:) has aligned access
                  remark #15305: vectorization support: vector length 4
                  remark #15309: vectorization support: normalized vectorization overhead 1.477
                  remark #15300: LOOP WAS VECTORIZED
                  remark #15448: unmasked aligned unit stride loads: 1 
                  remark #15475: --- begin vector cost summary ---
                  remark #15476: scalar cost: 22 
                  remark #15477: vector cost: 16.250 
                  remark #15478: estimated potential speedup: 1.320 
                  remark #15488: --- end vector cost summary ---
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1533,31)
               <Remainder loop for vectorization>
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1535,23)
                  remark #17102: loop was not parallelized: not a parallelization candidate
                  remark #15523: loop was not vectorized: loop control variable i_min was found, but loop iteration count cannot be computed before executing the loop
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1542,23)
                  remark #17102: loop was not parallelized: not a parallelization candidate
                  remark #15523: loop was not vectorized: loop control variable i_max was found, but loop iteration count cannot be computed before executing the loop
               LOOP END
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1564,31)
               remark #25399: memcopy generated
               remark #17104: loop was not parallelized: existence of parallel dependence
               remark #17106: parallel dependence: assumed OUTPUT dependence between at (1564:31) and at (1564:31)
               remark #17106: parallel dependence: assumed OUTPUT dependence between at (1564:31) and at (1564:31)
               remark #15542: loop was not vectorized: inner loop was already vectorized

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1564,31)
                  remark #17108: loop was not parallelized: insufficient computational work
                  remark #15388: vectorization support: reference at (1564:88) has aligned access   [ comm_ptsrc_comp_mod.f90(1564,88) ]
                  remark #15389: vectorization support: reference self(:,j) has unaligned access   [ comm_ptsrc_comp_mod.f90(1564,88) ]
                  remark #15381: vectorization support: unaligned access used inside loop body
                  remark #15305: vectorization support: vector length 2
                  remark #15309: vectorization support: normalized vectorization overhead 0.750
                  remark #15300: LOOP WAS VECTORIZED
                  remark #15449: unmasked aligned unit stride stores: 1 
                  remark #15450: unmasked unaligned unit stride loads: 1 
                  remark #15475: --- begin vector cost summary ---
                  remark #15476: scalar cost: 4 
                  remark #15477: vector cost: 2.000 
                  remark #15478: estimated potential speedup: 1.770 
                  remark #15488: --- end vector cost summary ---
                  remark #25015: Estimate of max trip count of loop=6
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1564,31)
               <Remainder loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=12
               LOOP END
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1564,88)
               remark #25399: memcopy generated
               remark #17104: loop was not parallelized: existence of parallel dependence
               remark #17106: parallel dependence: assumed OUTPUT dependence between self(:,j) (1564:88) and self(:,j) (1564:88)
               remark #17106: parallel dependence: assumed OUTPUT dependence between self(:,j) (1564:88) and self(:,j) (1564:88)
               remark #15542: loop was not vectorized: inner loop was already vectorized

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1564,88)
                  remark #17108: loop was not parallelized: insufficient computational work
                  remark #15388: vectorization support: reference self(:,j) has aligned access
                  remark #15388: vectorization support: reference at (1564:88) has aligned access
                  remark #15305: vectorization support: vector length 2
                  remark #15309: vectorization support: normalized vectorization overhead 1.333
                  remark #15300: LOOP WAS VECTORIZED
                  remark #15448: unmasked aligned unit stride loads: 1 
                  remark #15449: unmasked aligned unit stride stores: 1 
                  remark #15475: --- begin vector cost summary ---
                  remark #15476: scalar cost: 4 
                  remark #15477: vector cost: 1.500 
                  remark #15478: estimated potential speedup: 2.180 
                  remark #15488: --- end vector cost summary ---
                  remark #25015: Estimate of max trip count of loop=6
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1564,88)
               <Alternate Alignment Vectorized Loop>
                  remark #25015: Estimate of max trip count of loop=6
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1564,88)
               <Remainder loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=12
               LOOP END
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1568,38)
               remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(1568,38) ]
               remark #17108: loop was not parallelized: insufficient computational work
               remark #15388: vectorization support: reference P_TOT(:) has aligned access
               remark #15305: vectorization support: vector length 2
               remark #15399: vectorization support: unroll factor set to 4
               remark #15309: vectorization support: normalized vectorization overhead 0.279
               remark #15300: LOOP WAS VECTORIZED
               remark #15448: unmasked aligned unit stride loads: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 9 
               remark #15477: vector cost: 8.500 
               remark #15478: estimated potential speedup: 1.050 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1568,38)
            <Remainder loop for vectorization>
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1568,20)
               remark #17108: loop was not parallelized: insufficient computational work
               remark #15388: vectorization support: reference P_TOT(:) has aligned access   [ comm_ptsrc_comp_mod.f90(1568,28) ]
               remark #15388: vectorization support: reference P_TOT(:) has aligned access
               remark #15305: vectorization support: vector length 2
               remark #15309: vectorization support: normalized vectorization overhead 0.038
               remark #15300: LOOP WAS VECTORIZED
               remark #15448: unmasked aligned unit stride loads: 1 
               remark #15449: unmasked aligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 109 
               remark #15477: vector cost: 39.500 
               remark #15478: estimated potential speedup: 2.750 
               remark #15482: vectorized math library calls: 1 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1568,20)
            <Remainder loop for vectorization>
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1569,36)
               remark #17108: loop was not parallelized: insufficient computational work
               remark #15388: vectorization support: reference P_TOT(:) has aligned access
               remark #15305: vectorization support: vector length 2
               remark #15399: vectorization support: unroll factor set to 4
               remark #15309: vectorization support: normalized vectorization overhead 0.950
               remark #15300: LOOP WAS VECTORIZED
               remark #15448: unmasked aligned unit stride loads: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 6 
               remark #15477: vector cost: 2.500 
               remark #15478: estimated potential speedup: 2.290 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1569,36)
            <Remainder loop for vectorization>
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1569,20)
               remark #17108: loop was not parallelized: insufficient computational work
               remark #15388: vectorization support: reference P_TOT(:) has aligned access
               remark #15388: vectorization support: reference P_TOT(:) has aligned access
               remark #15305: vectorization support: vector length 2
               remark #15399: vectorization support: unroll factor set to 4
               remark #15309: vectorization support: normalized vectorization overhead 0.015
               remark #15300: LOOP WAS VECTORIZED
               remark #15448: unmasked aligned unit stride loads: 1 
               remark #15449: unmasked aligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 59 
               remark #15477: vector cost: 33.500 
               remark #15478: estimated potential speedup: 1.740 
               remark #15486: divides: 2 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1569,20)
            <Remainder loop for vectorization>
               remark #15388: vectorization support: reference P_TOT(:) has aligned access
               remark #15388: vectorization support: reference P_TOT(:) has aligned access
               remark #15305: vectorization support: vector length 2
               remark #15309: vectorization support: normalized vectorization overhead 0.197
               remark #15301: REMAINDER LOOP WAS VECTORIZED
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1569,20)
            <Remainder loop for vectorization>
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1570,28)
               remark #17108: loop was not parallelized: insufficient computational work
               remark #15388: vectorization support: reference P_TOT(:) has aligned access
               remark #15388: vectorization support: reference X(:) has aligned access
               remark #15305: vectorization support: vector length 2
               remark #15399: vectorization support: unroll factor set to 4
               remark #15309: vectorization support: normalized vectorization overhead 0.594
               remark #15300: LOOP WAS VECTORIZED
               remark #15448: unmasked aligned unit stride loads: 2 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 8 
               remark #15477: vector cost: 4.000 
               remark #15478: estimated potential speedup: 1.940 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1570,28)
            <Remainder loop for vectorization>
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1571,33)
               remark #17108: loop was not parallelized: insufficient computational work
               remark #15388: vectorization support: reference X(:) has aligned access
               remark #15388: vectorization support: reference P_TOT(:) has aligned access   [ comm_ptsrc_comp_mod.f90(1571,43) ]
               remark #15305: vectorization support: vector length 2
               remark #15399: vectorization support: unroll factor set to 4
               remark #15309: vectorization support: normalized vectorization overhead 0.359
               remark #15300: LOOP WAS VECTORIZED
               remark #15448: unmasked aligned unit stride loads: 2 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 16 
               remark #15477: vector cost: 8.000 
               remark #15478: estimated potential speedup: 1.950 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1571,33)
            <Remainder loop for vectorization>
               remark #15388: vectorization support: reference X(:) has aligned access
               remark #15388: vectorization support: reference P_TOT(:) has aligned access   [ comm_ptsrc_comp_mod.f90(1571,43) ]
               remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
               remark #15305: vectorization support: vector length 2
               remark #15309: vectorization support: normalized vectorization overhead 1.650
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1589,17)
               remark #25399: memcopy generated
               remark #17104: loop was not parallelized: existence of parallel dependence
               remark #17106: parallel dependence: assumed OUTPUT dependence between at (1589:17) and at (1589:17)
               remark #17106: parallel dependence: assumed OUTPUT dependence between at (1589:17) and at (1589:17)
               remark #15542: loop was not vectorized: inner loop was already vectorized

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1589,17)
                  remark #17108: loop was not parallelized: insufficient computational work
                  remark #15388: vectorization support: reference at (1589:17) has aligned access
                  remark #15388: vectorization support: reference THETA(:) has aligned access
                  remark #15305: vectorization support: vector length 2
                  remark #15309: vectorization support: normalized vectorization overhead 1.667
                  remark #15300: LOOP WAS VECTORIZED
                  remark #15448: unmasked aligned unit stride loads: 1 
                  remark #15449: unmasked aligned unit stride stores: 1 
                  remark #15475: --- begin vector cost summary ---
                  remark #15476: scalar cost: 4 
                  remark #15477: vector cost: 1.500 
                  remark #15478: estimated potential speedup: 2.080 
                  remark #15488: --- end vector cost summary ---
                  remark #25015: Estimate of max trip count of loop=6
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1589,17)
               <Alternate Alignment Vectorized Loop>
                  remark #25015: Estimate of max trip count of loop=6
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1589,17)
               <Remainder loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=12
               LOOP END
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1592,17)
               remark #17102: loop was not parallelized: not a parallelization candidate
               remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1597,20)
                  remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(1598,23) ]
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed ANTI dependence between AMP(k,p) (1599:23) and data_(l,pix,p) (1599:23)
                  remark #15346: vector dependence: assumed FLOW dependence between data_(l,pix,p) (1599:23) and AMP(k,p) (1599:23)
               LOOP END
            LOOP END
         LOOP END
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1613,8)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1615,11)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1620,14)
            remark #25399: memcopy generated
            remark #17104: loop was not parallelized: existence of parallel dependence
            remark #17106: parallel dependence: assumed OUTPUT dependence between THETA(:) (1620:14) and THETA(:) (1620:14)
            remark #17106: parallel dependence: assumed OUTPUT dependence between THETA(:) (1620:14) and THETA(:) (1620:14)
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1620,14)
               remark #17108: loop was not parallelized: insufficient computational work
               remark #15388: vectorization support: reference THETA(:) has aligned access
               remark #15389: vectorization support: reference at (1620:14) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 2
               remark #15309: vectorization support: normalized vectorization overhead 0.750
               remark #15300: LOOP WAS VECTORIZED
               remark #15449: unmasked aligned unit stride stores: 1 
               remark #15450: unmasked unaligned unit stride loads: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 4 
               remark #15477: vector cost: 2.000 
               remark #15478: estimated potential speedup: 1.770 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=6
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1620,14)
            <Remainder loop for vectorization>
               remark #25015: Estimate of max trip count of loop=12
            LOOP END
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1621,14)
            remark #17102: loop was not parallelized: not a parallelization candidate
            remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1628,17)
               remark #17104: loop was not parallelized: existence of parallel dependence
               remark #17106: parallel dependence: assumed ANTI dependence between self%COMM_PTSRC_COMP (1629:20) and data_(l) (1630:56)
               remark #17106: parallel dependence: assumed FLOW dependence between data_(l) (1630:56) and self%COMM_PTSRC_COMP (1629:20)
               remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(1630,56) ]
               remark #15344: loop was not vectorized: vector dependence prevents vectorization
               remark #15346: vector dependence: assumed ANTI dependence between self%COMM_PTSRC_COMP (1629:20) and data_(l) (1630:56)
               remark #15346: vector dependence: assumed FLOW dependence between data_(l) (1630:56) and self%COMM_PTSRC_COMP (1629:20)
            LOOP END
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1661,23)
            remark #17102: loop was not parallelized: not a parallelization candidate
            remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1675,14)
            remark #17102: loop was not parallelized: not a parallelization candidate
            remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1680,17)
               remark #17104: loop was not parallelized: existence of parallel dependence
               remark #17106: parallel dependence: assumed ANTI dependence between self%COMM_PTSRC_COMP (1681:20) and data_(l) (1684:67)
               remark #17106: parallel dependence: assumed FLOW dependence between data_(l) (1684:67) and self%COMM_PTSRC_COMP (1681:20)
               remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(1684,67) ]
               remark #15344: loop was not vectorized: vector dependence prevents vectorization
               remark #15346: vector dependence: assumed ANTI dependence between self%COMM_PTSRC_COMP (1681:20) and data_(l) (1684:67)
               remark #15346: vector dependence: assumed FLOW dependence between data_(l) (1684:67) and self%COMM_PTSRC_COMP (1681:20)
            LOOP END
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1696,54)
            remark #25399: memcopy generated
            remark #17104: loop was not parallelized: existence of parallel dependence
            remark #17106: parallel dependence: assumed OUTPUT dependence between at (1696:54) and at (1696:54)
            remark #17106: parallel dependence: assumed OUTPUT dependence between at (1696:54) and at (1696:54)
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1696,54)
               remark #17108: loop was not parallelized: insufficient computational work
               remark #15388: vectorization support: reference at (1696:81) has aligned access   [ comm_ptsrc_comp_mod.f90(1696,81) ]
               remark #15389: vectorization support: reference self(k,:,1) has unaligned access   [ comm_ptsrc_comp_mod.f90(1696,81) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 2
               remark #15309: vectorization support: normalized vectorization overhead 0.750
               remark #15300: LOOP WAS VECTORIZED
               remark #15449: unmasked aligned unit stride stores: 1 
               remark #15450: unmasked unaligned unit stride loads: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 4 
               remark #15477: vector cost: 2.000 
               remark #15478: estimated potential speedup: 1.770 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=6
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1696,54)
            <Remainder loop for vectorization>
               remark #25015: Estimate of max trip count of loop=12
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1529,26)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1529,26)
   remark #15388: vectorization support: reference X(i) has aligned access   [ comm_ptsrc_comp_mod.f90(1529,57) ]
   remark #15388: vectorization support: reference P_TOT(i) has aligned access
   remark #15388: vectorization support: reference P_TOT(i) has aligned access   [ comm_ptsrc_comp_mod.f90(1529,37) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.104
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 2 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 46 
   remark #15477: vector cost: 24.000 
   remark #15478: estimated potential speedup: 1.810 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=12
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1529,26)
<Alternate Alignment Vectorized Loop>
   remark #25015: Estimate of max trip count of loop=12
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1529,26)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference X(i) has unaligned access   [ comm_ptsrc_comp_mod.f90(1529,57) ]
   remark #15388: vectorization support: reference P_TOT(i) has aligned access
   remark #15388: vectorization support: reference P_TOT(i) has aligned access   [ comm_ptsrc_comp_mod.f90(1529,37) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.345
   remark #25015: Estimate of max trip count of loop=101
LOOP END

Fusion of IFs performed in comm_ptsrc_comp_mod_mp_sampleptsrcspecind_ at line 1535

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(1288,75):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1288,58):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1288,53):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1289,50):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1288,50):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1288,68):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1288,65):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1304,14):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(1304,14):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (8, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1308,27):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1310,17):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (32, 0)
comm_ptsrc_comp_mod.f90(1316,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1316,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1316,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1400,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1400,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1400,25):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1620,14):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1620,14):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1620,14):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1696,54):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1696,54):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1696,54):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1475,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1475,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1475,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1500,20):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1500,20):remark #34026: call to memset implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1564,31):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1564,31):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1564,31):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1564,88):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1564,88):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1564,88):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1589,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1589,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1589,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1364,14):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1364,14):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1364,14):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1335,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1335,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1335,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1338,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1338,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1338,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1344,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1344,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1344,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1277,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_sampleptsrcspecind_] comm_ptsrc_comp_mod.f90:1277

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    3718
            Global    :     703
            Local     :    3015
        Regenerable   :     544
        Spilled       :      71
        
    Routine stack
        Variables     :    1956 bytes*
            Reads     :     312 [2.45e+05 ~ 6.2%]
            Writes    :     361 [5.32e+04 ~ 1.4%]
        Spills        :     616 bytes*
            Reads     :     157 [6.17e+04 ~ 1.6%]
            Writes    :     122 [4.24e+04 ~ 1.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::LNL_PTSRC_MULTI

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::LNL_PTSRC_MULTI) [15/20=75.0%] comm_ptsrc_comp_mod.f90(1732,12)
  -> EXTERN: (1742,5) for_alloc_allocatable
  -> EXTERN: (1742,5) for_check_mult_overflow64
  -> EXTERN: (1745,13) mpi_bcast_
  -> EXTERN: (1747,8) for_realloc_lhs
  -> EXTERN: (1753,10) mpi_bcast_
  -> EXTERN: (1754,10) mpi_bcast_
  -> EXTERN: (1759,8) for_dealloc_allocatable
  -> EXTERN: (1767,11) for_dealloc_allocatable
  -> INDIRECT-: (1778,12)  (*((P64*) *((P64*) (&((F_INT_PTR$P$14_V$eca *)comm_ptsrc_comp_mod_mp_c_lnl_$45_V$3769->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$eee)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_lnl_ptsrc_multi_$L_V$5cf5.0.20)), l:(comm_ptsrc_comp_mod_mp_c_lnl_$45_V$3769->COMM_PTSRC_COMP_MOD$.btCOMM_PTSRC_COMP$F_INT_V$ef7)[0(SI32), l:0(SI64)]] + 56(SI64)))))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1781,12)  (*((P64*) comm_ptsrc_comp_mod_mp_c_lnl_$45_V$3770))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1787,18)  (*((P64*) *((P64*) (&((COMM_DATA_SET$N$29_V$1039 *)comm_data_mod_mp_data__V$3758)[(EXPR_CONV.SI32.SI64(comm_ptsrc_comp_mod_mp_lnl_ptsrc_multi_$L_V$5cf5.0.20)), l:comm_data_mod_mp_data__V$3761[0(SI32), l:0(SI64)]] + 56(SI64)))))[5(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1793,10) mpi_reduce_
  -> EXTERN: (1815,5) for_dealloc_allocatable
  -> EXTERN: (1817,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(1747,8)
<Multiversioned v1>
   remark #25233: Loop multiversioned for stride tests on Assumed shape arrays
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference THETA(:) has aligned access
   remark #15389: vectorization support: reference p(:) has unaligned access
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.750
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 1.990 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1747,8)
<Remainder loop for vectorization, Multiversioned v1>
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1747,8)
<Multiversioned v2>
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference THETA(:) has aligned access
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <p(:)>, stride is unknown to compiler
   remark #15305: vectorization support: vector length 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15452: unmasked strided loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 1.600 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1747,8)
<Remainder loop for vectorization, Multiversioned v2>
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1748,8)
<Distributed chunk1>
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c_lnl(1,l) (1749:42) and THETA(l) (1750:18)
   remark #17106: parallel dependence: assumed FLOW dependence between THETA(l) (1750:18) and c_lnl(1,l) (1749:42)
   remark #25426: Loop Distributed (2 way) 
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.000
   remark #15301: PARTIAL LOOP WAS VECTORIZED
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 1 
   remark #15477: vector cost: 0.750 
   remark #15478: estimated potential speedup: 1.310 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1748,8)
<Remainder loop for vectorization, Distributed chunk1>
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1748,8)
<Distributed chunk2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c_lnl(1,l) (1749:42) and THETA(l) (1750:18)
   remark #15346: vector dependence: assumed FLOW dependence between THETA(l) (1750:18) and c_lnl(1,l) (1749:42)
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1765,40)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable l was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1774,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1784,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between pix (1785:11) and pix (1787:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between pix (1787:18) and pix (1785:11)
      remark #15382: vectorization support: call to function (Indirect call) cannot be vectorized   [ comm_ptsrc_comp_mod.f90(1787,18) ]
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between pix (1785:11) and pix (1787:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between pix (1787:18) and pix (1785:11)
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1811,8)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(1805,14) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(1808,8) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference THETA(l) has unaligned access   [ comm_ptsrc_comp_mod.f90(1805,59) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <c_lnl(2,l)>, stride is unknown to compiler   [ comm_ptsrc_comp_mod.f90(1804,15) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <c_lnl(1,l)>, masked, stride is unknown to compiler   [ comm_ptsrc_comp_mod.f90(1805,68) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <c_lnl(2,l)>, stride is unknown to compiler   [ comm_ptsrc_comp_mod.f90(1806,39) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.183
   remark #15452: unmasked strided loads: 2 
   remark #15456: masked unaligned unit stride loads: 1 
   remark #15460: masked strided loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 52 
   remark #15477: vector cost: 63.000 
   remark #15478: estimated potential speedup: 0.820 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(1740,44):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1732,12):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_lnl_ptsrc_multi_] comm_ptsrc_comp_mod.f90:1732

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   19[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :     464
            Global    :      98
            Local     :     366
        Regenerable   :      76
        Spilled       :       9
        
    Routine stack
        Variables     :     196 bytes*
            Reads     :      24 [1.80e+01 ~ 2.7%]
            Writes    :      41 [2.90e+01 ~ 4.3%]
        Spills        :      32 bytes*
            Reads     :       6 [8.11e+00 ~ 1.2%]
            Writes    :       6 [5.44e+00 ~ 0.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::LNL_PTSRC

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::LNL_PTSRC) [16/20=80.0%] comm_ptsrc_comp_mod.f90(1724,12)


    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(1724,12):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_lnl_ptsrc_] comm_ptsrc_comp_mod.f90:1724

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rdi zmm0]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::INITPTSRCPRECOND

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::INITPTSRCPRECOND) [17/20=85.0%] comm_ptsrc_comp_mod.f90(968,14)
  -> EXTERN: (981,35) for_deallocate_all
  -> EXTERN: (983,10) mpi_comm_rank_
  -> EXTERN: (986,10) wall_time_
  -> EXTERN: (987,5) for_alloc_allocatable
  -> EXTERN: (987,5) for_check_mult_overflow64
  -> EXTERN: (988,5) for_alloc_allocatable
  -> EXTERN: (988,5) for_check_mult_overflow64
  -> EXTERN: (988,5) for_alloc_allocatable
  -> EXTERN: (988,5) for_check_mult_overflow64
  -> EXTERN: (996,24) strcmp
  -> INDIRECT-: (1002,20)  (*((P64*) comm_ptsrc_comp_mod_mp_initptsrcprecond_$C1$61_V$4e75.0.13))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1014,30) strcmp
  -> INDIRECT-: (1020,26)  (*((P64*) comm_ptsrc_comp_mod_mp_initptsrcprecond_$C2$59_V$4e51.0.13))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1048,36)  (*((P64*) comm_ptsrc_comp_mod_mp_initptsrcprecond_$PT1$58_V$4e3f.0.13))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1049,36)  (*((P64*) comm_ptsrc_comp_mod_mp_initptsrcprecond_$PT2$57_V$4e2d.0.13))[16(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1064,23)  (*((P64*) comm_ptsrc_comp_mod_mp_initptsrcprecond_$C2$59_V$4e51.0.13))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1067,17)  (*((P64*) comm_ptsrc_comp_mod_mp_initptsrcprecond_$C1$61_V$4e75.0.13))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1071,13) mpi_reduce_
  -> EXTERN: (1079,27) strcmp
  -> INDIRECT-: (1085,23)  (*((P64*) comm_ptsrc_comp_mod_mp_initptsrcprecond_$C1$61_V$4e75.0.13))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1092,20)  (*((P64*) comm_ptsrc_comp_mod_mp_initptsrcprecond_$C1$61_V$4e75.0.13))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1099,27) strcmp
  -> INDIRECT-: (1105,23)  (*((P64*) comm_ptsrc_comp_mod_mp_initptsrcprecond_$C1$61_V$4e75.0.13))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> INDIRECT-: (1112,20)  (*((P64*) comm_ptsrc_comp_mod_mp_initptsrcprecond_$C1$61_V$4e75.0.13))[1(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (1119,16) wall_time_
  -> EXTERN: (1120,16) INVERT_MATRIX_WITH_MASK_DP
  -> EXTERN: (1121,16) wall_time_
  -> EXTERN: (1122,21) for_write_seq_lis
  -> EXTERN: (1122,21) for_write_seq_lis_xmit
  -> EXTERN: (1123,11) for_alloc_allocatable
  -> EXTERN: (1123,11) for_check_mult_overflow64
  -> EXTERN: (1124,11) for_realloc_lhs
  -> EXTERN: (1124,11) for_dealloc_allocatable
  -> EXTERN: (1127,10) wall_time_
  -> EXTERN: (1128,24) for_write_seq_lis
  -> EXTERN: (1128,24) for_write_seq_lis_xmit
  -> EXTERN: (1130,5) for_dealloc_allocatable
  -> EXTERN: (1130,5) for_dealloc_allocatable
  -> EXTERN: (1135,3) for_dealloc_allocatable
  -> EXTERN: (1135,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(987,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable ? was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(1099,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(991,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between MAT(:,:) (991:8) and MAT(:,:) (991:8)
      remark #17106: parallel dependence: assumed OUTPUT dependence between MAT(:,:) (991:8) and MAT(:,:) (991:8)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(991,8)
         remark #25408: memset generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between MAT(:,:) (991:8) and MAT(:,:) (991:8)
         remark #17106: parallel dependence: assumed OUTPUT dependence between MAT(:,:) (991:8) and MAT(:,:) (991:8)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(991,8)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15389: vectorization support: reference MAT(:,:) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 2
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.300
            remark #15300: LOOP WAS VECTORIZED
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 2.500 
            remark #15478: estimated potential speedup: 1.450 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(991,8)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(996,24)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(996,24)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1010,14)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1014,30)
            remark #17102: loop was not parallelized: not a parallelization candidate
            remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1014,30)
               remark #17102: loop was not parallelized: not a parallelization candidate
               remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(1023,17)
               remark #17102: loop was not parallelized: not a parallelization candidate
               remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(1028,20)
                  remark #17102: loop was not parallelized: not a parallelization candidate
                  remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

                  LOOP BEGIN at comm_ptsrc_comp_mod.f90(1038,23)
                     remark #17102: loop was not parallelized: not a parallelization candidate
                     remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
                  LOOP END
               LOOP END
            LOOP END
         LOOP END
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1096,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1079,27)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1088,14)
         remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
         remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
         remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(1091,14) ]
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed ANTI dependence between PT1(k1,j,2) (1090:43) and MAT2(i1,:) (1090:17)
         remark #17106: parallel dependence: assumed FLOW dependence between MAT2(i1,:) (1090:17) and PT1(k1,j,2) (1090:43)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1090,17)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15329: vectorization support: non-unit strided store was emulated for the variable <MAT2(i1,:)>, stride is unknown to compiler
            remark #15328: vectorization support: non-unit strided load was emulated for the variable <MAT2(i1,:)>, stride is unknown to compiler
            remark #15305: vectorization support: vector length 2
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.136
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15452: unmasked strided loads: 1 
            remark #15453: unmasked strided stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 5.500 
            remark #15478: estimated potential speedup: 1.080 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1090,17)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1099,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1099,27)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1108,14)
         remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
         remark #25452: Original Order found to be proper, but by a close margin
         remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(1111,14) ]
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed ANTI dependence between PT1(k1,j,2) (1110:43) and MAT2(:,i1) (1110:17)
         remark #17106: parallel dependence: assumed FLOW dependence between MAT2(:,i1) (1110:17) and PT1(k1,j,2) (1110:43)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1110,17)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1110,17)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference MAT2(:,i1) has aligned access
            remark #15388: vectorization support: reference MAT2(:,i1) has aligned access
            remark #15305: vectorization support: vector length 2
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.500
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 3.000 
            remark #15478: estimated potential speedup: 1.940 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1110,17)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1115,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <MAT2(i1,i1)>, stride is unknown to compiler   [ comm_ptsrc_comp_mod.f90(1116,14) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <MAT2(i1,i1)>, stride is unknown to compiler   [ comm_ptsrc_comp_mod.f90(1116,28) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.100
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15452: unmasked strided loads: 1 
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 6 
      remark #15477: vector cost: 5.000 
      remark #15478: estimated potential speedup: 1.190 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1115,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(1124,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between p_cr(1,j,:,:) (1124:11) and p_cr(1,j,:,:) (1124:11)
      remark #17106: parallel dependence: assumed OUTPUT dependence between p_cr(1,j,:,:) (1124:11) and p_cr(1,j,:,:) (1124:11)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(1124,11)
         remark #25399: memcopy generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between p_cr(1,j,:,:) (1124:11) and p_cr(1,j,:,:) (1124:11)
         remark #17106: parallel dependence: assumed OUTPUT dependence between p_cr(1,j,:,:) (1124:11) and p_cr(1,j,:,:) (1124:11)
         remark #15542: loop was not vectorized: inner loop was already vectorized
         remark #25015: Estimate of max trip count of loop=1

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1124,11)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1124,11)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference p_cr(1,j,:,:) has aligned access
            remark #15388: vectorization support: reference MAT2(:,:) has aligned access
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 5.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 1.260 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1124,11)
         <Alternate Alignment Vectorized Loop>
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(1124,11)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(977,55):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(977,50):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(987,5):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
comm_ptsrc_comp_mod.f90(987,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (1, 0)
comm_ptsrc_comp_mod.f90(991,8):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(991,8):remark #34026: call to memset implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(993,8):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(993,8):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (8, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1076,11):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(1076,11):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (8, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1096,11):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(1096,11):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (8, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1124,11):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1124,11):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(1124,11):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(1099,27):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1101,17):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1079,27):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1081,17):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(996,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(998,14):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1010,14):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
comm_ptsrc_comp_mod.f90(1010,14):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (8, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1014,30):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(1016,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(968,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_initptsrcprecond_] comm_ptsrc_comp_mod.f90:968

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm6]
        
    Routine temporaries
        Total         :    1189
            Global    :     288
            Local     :     901
        Regenerable   :     179
        Spilled       :      89
        
    Routine stack
        Variables     :    1932 bytes*
            Reads     :     201 [8.06e+02 ~ 5.5%]
            Writes    :     352 [1.55e+03 ~ 10.6%]
        Spills        :     672 bytes*
            Reads     :     142 [1.03e+03 ~ 7.0%]
            Writes    :     110 [8.18e+02 ~ 5.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::DUMP_BEAMS_TO_HDF

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::DUMP_BEAMS_TO_HDF) [18/20=90.0%] comm_ptsrc_comp_mod.f90(740,14)
  -> EXTERN: (755,13) __resetsp_inlined
  -> EXTERN: (755,13) for_inquire
  -> EXTERN: (755,13) __getsp_inlined
  -> EXTERN: (755,18) for_trim
  -> EXTERN: (755,23) _alloca
  -> EXTERN: (756,16) REPORT_ERROR
  -> EXTERN: (756,16) __resetsp_inlined
  -> EXTERN: (756,16) __getsp_inlined
  -> EXTERN: (756,79) _alloca
  -> EXTERN: (756,79) for_concat
  -> EXTERN: (756,81) for_trim
  -> EXTERN: (756,86) _alloca
  -> EXTERN: (757,10) mpi_barrier_
  -> EXTERN: (759,24) OPEN_HDF_FILE
  -> EXTERN: (763,18) CREATE_HDF_GROUP
  -> EXTERN: (763,46) for_trim
  -> EXTERN: (763,51) for_adjustl
  -> EXTERN: (765,16) ANG2PIX_RING
  -> EXTERN: (766,11) for_write_int_lis
  -> EXTERN: (767,11) for_concat
  -> EXTERN: (767,19) for_trim
  -> EXTERN: (767,24) for_adjustl
  -> EXTERN: (767,54) for_trim
  -> EXTERN: (767,59) for_adjustl
  -> EXTERN: (769,19) H5ESET_AUTO_F
  -> EXTERN: (770,19) H5OGET_INFO_BY_NAME_F
  -> EXTERN: (770,58) for_trim
  -> EXTERN: (770,63) for_adjustl
  -> EXTERN: (771,31) H5GUNLINK_F
  -> EXTERN: (771,65) for_trim
  -> EXTERN: (771,70) for_adjustl
  -> EXTERN: (772,19) CREATE_HDF_GROUP
  -> EXTERN: (772,42) for_trim
  -> EXTERN: (776,16) mpi_reduce_
  -> EXTERN: (778,14) for_alloc_allocatable
  -> EXTERN: (778,14) for_check_mult_overflow64
  -> EXTERN: (778,14) for_alloc_allocatable
  -> EXTERN: (778,14) for_check_mult_overflow64
  -> EXTERN: (785,22) mpi_recv_
  -> EXTERN: (787,25) mpi_recv_
  -> EXTERN: (789,25) mpi_recv_
  -> EXTERN: (789,25) __getsp_inlined
  -> EXTERN: (789,25) __resetsp_inlined
  -> EXTERN: (789,34) _alloca
  -> EXTERN: (810,19) __resetsp_inlined
  -> EXTERN: (810,19) WRITE_HDF_1D_INT
  -> EXTERN: (810,19) __getsp_inlined
  -> EXTERN: (810,35) for_trim
  -> EXTERN: (810,40) for_adjustl
  -> EXTERN: (810,55) for_concat
  -> EXTERN: (810,55) _alloca
  -> EXTERN: (811,19) __resetsp_inlined
  -> EXTERN: (811,19) WRITE_HDF_2D_DP
  -> EXTERN: (811,19) __getsp_inlined
  -> EXTERN: (811,35) for_trim
  -> EXTERN: (811,40) for_adjustl
  -> EXTERN: (811,55) for_concat
  -> EXTERN: (811,55) _alloca
  -> EXTERN: (812,14) for_dealloc_allocatable
  -> EXTERN: (812,14) for_dealloc_allocatable
  -> EXTERN: (815,19) mpi_send_
  -> EXTERN: (817,22) __resetsp_inlined
  -> EXTERN: (817,22) mpi_send_
  -> EXTERN: (817,22) __getsp_inlined
  -> EXTERN: (817,31) _alloca
  -> EXTERN: (818,22) mpi_send_
  -> EXTERN: (823,24) CLOSE_HDF_FILE
  -> EXTERN: (825,3) for_dealloc_allocatable
  -> EXTERN: (825,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(760,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (763:51) and at (763:46)
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (763:46) and at (763:51)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(761,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (763:51) and at (763:46)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (763:46) and at (763:51)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(781,14)
         remark #25399: memcopy generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between IND(:) (781:14) and IND(:) (781:14)
         remark #17106: parallel dependence: assumed OUTPUT dependence between IND(:) (781:14) and IND(:) (781:14)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(781,14)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference IND(:) has aligned access
            remark #15389: vectorization support: reference at (781:14) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 0.600
            remark #15300: LOOP WAS VECTORIZED
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.250 
            remark #15478: estimated potential speedup: 2.900 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(781,14)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=24
         LOOP END
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(782,14)
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between BEAM(:,:) (782:14) and BEAM(:,:) (782:14)
         remark #17106: parallel dependence: assumed OUTPUT dependence between BEAM(:,:) (782:14) and BEAM(:,:) (782:14)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(782,14)
            remark #25399: memcopy generated
            remark #17104: loop was not parallelized: existence of parallel dependence
            remark #17106: parallel dependence: assumed OUTPUT dependence between BEAM(:,:) (782:14) and BEAM(:,:) (782:14)
            remark #17106: parallel dependence: assumed OUTPUT dependence between BEAM(:,:) (782:14) and BEAM(:,:) (782:14)
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(782,14)
            <Peeled loop for vectorization>
               remark #25015: Estimate of max trip count of loop=1
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(782,14)
               remark #17108: loop was not parallelized: insufficient computational work
               remark #15388: vectorization support: reference BEAM(:,:) has aligned access
               remark #15389: vectorization support: reference at (782:14) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 2
               remark #15309: vectorization support: normalized vectorization overhead 3.333
               remark #15300: LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15449: unmasked aligned unit stride stores: 1 
               remark #15450: unmasked unaligned unit stride loads: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 4 
               remark #15477: vector cost: 1.500 
               remark #15478: estimated potential speedup: 1.260 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=6
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(782,14)
            <Remainder loop for vectorization>
               remark #25015: Estimate of max trip count of loop=12
            LOOP END
         LOOP END
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(784,14)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
            remark #17104: loop was not parallelized: existence of parallel dependence
            remark #17106: parallel dependence: assumed OUTPUT dependence between at (789:34) and at (789:34)
            remark #17106: parallel dependence: assumed OUTPUT dependence between at (789:34) and at (789:34)
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
               remark #25399: memcopy generated
               remark #17104: loop was not parallelized: existence of parallel dependence
               remark #17106: parallel dependence: assumed OUTPUT dependence between at (789:34) and at (789:34)
               remark #17106: parallel dependence: assumed OUTPUT dependence between at (789:34) and at (789:34)
               remark #15542: loop was not vectorized: inner loop was already vectorized

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
               <Peeled loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=1
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
                  remark #17108: loop was not parallelized: insufficient computational work
                  remark #15388: vectorization support: reference at (789:34) has aligned access
                  remark #15388: vectorization support: reference BEAM(:,:) has aligned access
                  remark #15305: vectorization support: vector length 2
                  remark #15309: vectorization support: normalized vectorization overhead 4.667
                  remark #15300: LOOP WAS VECTORIZED
                  remark #15448: unmasked aligned unit stride loads: 1 
                  remark #15449: unmasked aligned unit stride stores: 1 
                  remark #15475: --- begin vector cost summary ---
                  remark #15476: scalar cost: 4 
                  remark #15477: vector cost: 1.500 
                  remark #15478: estimated potential speedup: 1.290 
                  remark #15488: --- end vector cost summary ---
                  remark #25015: Estimate of max trip count of loop=6
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
               <Alternate Alignment Vectorized Loop>
                  remark #25015: Estimate of max trip count of loop=6
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
               <Remainder loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=12
               LOOP END
            LOOP END
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
            remark #17104: loop was not parallelized: existence of parallel dependence
            remark #17106: parallel dependence: assumed OUTPUT dependence between BEAM(:,:) (789:34) and BEAM(:,:) (789:34)
            remark #17106: parallel dependence: assumed OUTPUT dependence between BEAM(:,:) (789:34) and BEAM(:,:) (789:34)
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
               remark #25399: memcopy generated
               remark #17104: loop was not parallelized: existence of parallel dependence
               remark #17106: parallel dependence: assumed OUTPUT dependence between BEAM(:,:) (789:34) and BEAM(:,:) (789:34)
               remark #17106: parallel dependence: assumed OUTPUT dependence between BEAM(:,:) (789:34) and BEAM(:,:) (789:34)
               remark #15542: loop was not vectorized: inner loop was already vectorized

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
               <Peeled loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=1
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
                  remark #17108: loop was not parallelized: insufficient computational work
                  remark #15388: vectorization support: reference BEAM(:,:) has aligned access
                  remark #15388: vectorization support: reference at (789:34) has aligned access
                  remark #15305: vectorization support: vector length 2
                  remark #15309: vectorization support: normalized vectorization overhead 4.667
                  remark #15300: LOOP WAS VECTORIZED
                  remark #15442: entire loop may be executed in remainder
                  remark #15448: unmasked aligned unit stride loads: 1 
                  remark #15449: unmasked aligned unit stride stores: 1 
                  remark #15475: --- begin vector cost summary ---
                  remark #15476: scalar cost: 4 
                  remark #15477: vector cost: 1.500 
                  remark #15478: estimated potential speedup: 1.290 
                  remark #15488: --- end vector cost summary ---
                  remark #25015: Estimate of max trip count of loop=6
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
               <Alternate Alignment Vectorized Loop>
                  remark #25015: Estimate of max trip count of loop=6
               LOOP END

               LOOP BEGIN at comm_ptsrc_comp_mod.f90(789,34)
               <Remainder loop for vectorization>
                  remark #25015: Estimate of max trip count of loop=12
               LOOP END
            LOOP END
         LOOP END
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(795,14)
         remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(807,14) ]
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed ANTI dependence between IND(j) (796:17) and IND(l+1) (805:17)
         remark #17106: parallel dependence: assumed FLOW dependence between IND(l+1) (805:17) and IND(j) (796:17)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(797,17)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference rtmp(:) has aligned access
            remark #15328: vectorization support: non-unit strided load was emulated for the variable <BEAM(j,:)>, stride is unknown to compiler
            remark #15305: vectorization support: vector length 2
            remark #15300: LOOP WAS VECTORIZED
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15452: unmasked strided loads: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 2.500 
            remark #15478: estimated potential speedup: 1.330 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(797,17)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(799,17)
            remark #17104: loop was not parallelized: existence of parallel dependence
            remark #17106: parallel dependence: assumed ANTI dependence between IND(l) (800:31) and IND(l+1) (801:20)
            remark #17106: parallel dependence: assumed FLOW dependence between IND(l+1) (801:20) and IND(l) (800:31)
            remark #17106: parallel dependence: assumed ANTI dependence between IND(l) (801:20) and IND(l+1) (801:20)
            remark #17106: parallel dependence: assumed FLOW dependence between IND(l+1) (801:20) and IND(l) (801:20)
            remark #17106: parallel dependence: assumed ANTI dependence between BEAM(l,:) (802:20) and BEAM(l+1,:) (802:20)
            remark #17106: parallel dependence: assumed FLOW dependence between BEAM(l+1,:) (802:20) and BEAM(l,:) (802:20)
            remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ comm_ptsrc_comp_mod.f90(803,20) ]

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(802,20)
               remark #17108: loop was not parallelized: insufficient computational work
               remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
               remark #15329: vectorization support: non-unit strided store was emulated for the variable <BEAM(l+1,:)>, stride is unknown to compiler
               remark #15328: vectorization support: non-unit strided load was emulated for the variable <BEAM(l,:)>, stride is unknown to compiler
               remark #15305: vectorization support: vector length 2
               remark #15452: unmasked strided loads: 1 
               remark #15453: unmasked strided stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 4 
               remark #15477: vector cost: 4.000 
               remark #15478: estimated potential speedup: 1.000 
               remark #15488: --- end vector cost summary ---
               remark #25439: unrolled with remainder by 2  
            LOOP END

            LOOP BEGIN at comm_ptsrc_comp_mod.f90(802,20)
            <Remainder>
            LOOP END
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(806,17)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference rtmp(:) has aligned access
            remark #15329: vectorization support: non-unit strided store was emulated for the variable <BEAM(l+1,:)>, stride is unknown to compiler
            remark #15305: vectorization support: vector length 2
            remark #15300: LOOP WAS VECTORIZED
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15453: unmasked strided stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 3.000 
            remark #15478: estimated potential speedup: 1.200 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(806,17)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(817,31)
         remark #25399: memcopy generated
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed OUTPUT dependence between at (817:31) and at (817:31)
         remark #17106: parallel dependence: assumed OUTPUT dependence between at (817:31) and at (817:31)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(817,31)
            remark #17108: loop was not parallelized: insufficient computational work
            remark #15388: vectorization support: reference at (817:31) has aligned access
            remark #15389: vectorization support: reference at (817:31) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 0.600
            remark #15300: LOOP WAS VECTORIZED
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.250 
            remark #15478: estimated potential speedup: 2.900 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at comm_ptsrc_comp_mod.f90(817,31)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=24
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(752,50):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(751,50):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(817,31):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(817,31):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(817,31):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(781,14):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(781,14):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(781,14):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(782,14):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(782,14):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(782,14):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(789,34):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(789,34):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(789,34):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(789,34):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(789,34):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(789,34):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(740,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_dump_beams_to_hdf_] comm_ptsrc_comp_mod.f90:740

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :     886
            Global    :     238
            Local     :     648
        Regenerable   :     244
        Spilled       :      63
        
    Routine stack
        Variables     :    5404 bytes*
            Reads     :      58 [2.47e+02 ~ 1.8%]
            Writes    :      78 [4.99e+02 ~ 3.6%]
        Spills        :     464 bytes*
            Reads     :     114 [5.26e+02 ~ 3.8%]
            Writes    :      74 [2.32e+02 ~ 1.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::INITPTSRCHDF

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::INITPTSRCHDF) [19/20=95.0%] comm_ptsrc_comp_mod.f90(436,14)
  -> EXTERN: (454,5) __resetsp_inlined
  -> EXTERN: (454,5) for_concat
  -> EXTERN: (454,5) __getsp_inlined
  -> EXTERN: (454,12) for_trim
  -> EXTERN: (454,17) _alloca
  -> EXTERN: (454,17) for_adjustl
  -> EXTERN: (454,25) _alloca
  -> EXTERN: (454,36) for_trim
  -> EXTERN: (454,41) for_adjustl
  -> EXTERN: (456,13) READ_HDF_2D_DP
  -> EXTERN: (456,13) __resetsp_inlined
  -> EXTERN: (456,13) __getsp_inlined
  -> EXTERN: (456,31) for_trim
  -> EXTERN: (456,36) for_adjustl
  -> EXTERN: (456,50) _alloca
  -> EXTERN: (456,50) for_concat
  -> EXTERN: (457,8) for_realloc_lhs
  -> EXTERN: (460,5) for_alloc_allocatable
  -> EXTERN: (460,5) for_check_mult_overflow64
  -> EXTERN: (461,10) __resetsp_inlined
  -> EXTERN: (461,10) READ_HDF_3D_DP
  -> EXTERN: (461,10) __getsp_inlined
  -> EXTERN: (461,28) for_trim
  -> EXTERN: (461,33) for_adjustl
  -> EXTERN: (461,47) for_concat
  -> EXTERN: (461,47) _alloca
  -> EXTERN: (468,5) for_dealloc_allocatable
  -> INDIRECT-: (471,10)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_initptsrchdf_$SELF_V$460b.0.8 + 56(SI64)))))[15(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (473,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(457,8)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(457,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15389: vectorization support: reference at (457:8) has unaligned access
      remark #15389: vectorization support: reference at (457:24) has unaligned access   [ comm_ptsrc_comp_mod.f90(457,24) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.062
      remark #15300: LOOP WAS VECTORIZED
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 32 
      remark #15477: vector cost: 20.000 
      remark #15478: estimated potential speedup: 1.580 
      remark #15486: divides: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(457,8)
   <Remainder loop for vectorization>
      remark #15389: vectorization support: reference at (457:8) has unaligned access
      remark #15389: vectorization support: reference at (457:24) has unaligned access   [ comm_ptsrc_comp_mod.f90(457,24) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.455
      remark #15301: REMAINDER LOOP WAS VECTORIZED
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(457,8)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(468,5)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 2 1 3 ) 
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (465:11) and at (465:11)
   remark #17106: parallel dependence: assumed OUTPUT dependence between at (465:11) and at (465:11)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(464,8)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(465,11)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(465,11)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (465:11) has aligned access
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <THETA(i,j,:)>, stride is unknown to compiler
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 2.200
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 1.570 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(465,11)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(446,48):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(436,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_initptsrchdf_] comm_ptsrc_comp_mod.f90:436

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm6]
        
    Routine temporaries
        Total         :     364
            Global    :      94
            Local     :     270
        Regenerable   :      68
        Spilled       :      17
        
    Routine stack
        Variables     :    3920 bytes*
            Reads     :      11 [9.50e+00 ~ 0.2%]
            Writes    :      51 [3.74e+01 ~ 0.8%]
        Spills        :      96 bytes*
            Reads     :      18 [5.76e+01 ~ 1.2%]
            Writes    :      13 [5.74e+01 ~ 1.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: COMM_PTSRC_COMP_MOD::DUMPPTSRCTOFITS

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (COMM_PTSRC_COMP_MOD::DUMPPTSRCTOFITS) [20/20=100.0%] comm_ptsrc_comp_mod.f90(333,14)
  -> EXTERN: (351,15) COMM_MAP_MOD^CONSTRUCTOR_MAP
  -> EXTERN: (352,8) for_realloc_lhs
  -> EXTERN: (352,8) for_dealloc_allocatable
  -> INDIRECT-: (352,18)  (*((P64*) *((P64*) (comm_ptsrc_comp_mod_mp_dumpptsrctofits_$SELF_V$42df.0.7 + 56(SI64)))))[7(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (353,8) __getsp_inlined
  -> EXTERN: (353,8) for_concat
  -> EXTERN: (353,8) __resetsp_inlined
  -> EXTERN: (353,19) for_trim
  -> EXTERN: (353,46) for_trim
  -> EXTERN: (353,76) for_trim
  -> EXTERN: (353,81) _alloca
  -> EXTERN: (354,13) __getsp_inlined
  -> INDIRECT-: (354,13)  (*((P64*) comm_ptsrc_comp_mod_mp_dumpptsrctofits_$MAP$50_V$42ff.0.7))[9(SI64)]
     [[ Unable to inline indirect callsite  <2>]]
  -> EXTERN: (354,13) __resetsp_inlined
  -> EXTERN: (354,27) for_trim
  -> EXTERN: (354,32) _alloca
  -> EXTERN: (354,41) _alloca
  -> EXTERN: (354,41) for_concat
  -> EXTERN: (354,43) for_trim
  -> EXTERN: (355,8) for_finalize
  -> EXTERN: (355,8) for_deallocate_all
  -> EXTERN: (362,16) INT2STRING
  -> EXTERN: (363,11) for_concat
  -> EXTERN: (363,18) for_trim
  -> EXTERN: (363,23) for_adjustl
  -> EXTERN: (363,45) for_trim
  -> EXTERN: (363,50) for_adjustl
  -> EXTERN: (364,16) CREATE_HDF_GROUP
  -> EXTERN: (364,44) for_trim
  -> EXTERN: (364,49) for_adjustl
  -> EXTERN: (365,16) __getsp_inlined
  -> EXTERN: (365,16) _alloca
  -> EXTERN: (365,16) WRITE_HDF_2D_DP
  -> EXTERN: (365,16) __resetsp_inlined
  -> EXTERN: (365,37) for_trim
  -> EXTERN: (365,42) for_adjustl
  -> EXTERN: (365,56) _alloca
  -> EXTERN: (365,56) for_concat
  -> EXTERN: (366,11) for_check_mult_overflow64
  -> EXTERN: (366,11) for_alloc_allocatable
  -> EXTERN: (372,16) __getsp_inlined
  -> EXTERN: (372,16) WRITE_HDF_3D_DP
  -> EXTERN: (372,16) __resetsp_inlined
  -> EXTERN: (372,37) for_trim
  -> EXTERN: (372,42) for_adjustl
  -> EXTERN: (372,56) _alloca
  -> EXTERN: (372,56) for_concat
  -> EXTERN: (373,11) for_dealloc_allocatable
  -> EXTERN: (376,19) GETLUN
  -> EXTERN: (377,8) __getsp_inlined
  -> EXTERN: (377,8) for_concat
  -> EXTERN: (377,8) __resetsp_inlined
  -> EXTERN: (377,19) for_trim
  -> EXTERN: (377,46) for_trim
  -> EXTERN: (377,51) _alloca
  -> EXTERN: (378,8) __getsp_inlined
  -> EXTERN: (378,8) for_open
  -> EXTERN: (378,8) __resetsp_inlined
  -> EXTERN: (378,23) for_trim
  -> EXTERN: (378,28) _alloca
  -> EXTERN: (378,37) _alloca
  -> EXTERN: (378,37) for_concat
  -> EXTERN: (378,39) for_trim
  -> EXTERN: (380,15) for_trim
  -> EXTERN: (380,31) for_cpstr
  -> EXTERN: (381,14) for_write_seq_lis
  -> EXTERN: (382,14) for_write_seq_lis_xmit
  -> EXTERN: (382,14) for_write_seq_lis
  -> EXTERN: (382,56) for_trim
  -> EXTERN: (383,14) for_write_seq_fmt_xmit
  -> EXTERN: (383,14) for_write_seq_fmt_xmit
  -> EXTERN: (383,14) for_write_seq_fmt
  -> EXTERN: (384,14) for_write_seq_lis
  -> EXTERN: (385,14) for_write_seq_lis
  -> EXTERN: (385,14) __getsp_inlined
  -> EXTERN: (385,14) __resetsp_inlined
  -> EXTERN: (385,94) memmove
  -> EXTERN: (385,94) _alloca
  -> EXTERN: (387,20) for_trim
  -> EXTERN: (387,36) for_cpstr
  -> EXTERN: (388,14) for_write_seq_lis
  -> EXTERN: (389,14) for_write_seq_lis_xmit
  -> EXTERN: (389,14) for_write_seq_lis
  -> EXTERN: (389,56) for_trim
  -> EXTERN: (390,14) for_write_seq_fmt_xmit
  -> EXTERN: (390,14) for_write_seq_fmt_xmit
  -> EXTERN: (390,14) for_write_seq_fmt
  -> EXTERN: (391,14) for_write_seq_lis
  -> EXTERN: (392,14) for_write_seq_lis
  -> EXTERN: (392,14) __getsp_inlined
  -> EXTERN: (392,14) __resetsp_inlined
  -> EXTERN: (392,93) memmove
  -> EXTERN: (392,93) _alloca
  -> EXTERN: (396,15) for_trim
  -> EXTERN: (396,31) for_cpstr
  -> EXTERN: (397,14) for_write_seq_lis
  -> EXTERN: (398,14) for_write_seq_lis_xmit
  -> EXTERN: (398,14) for_write_seq_lis
  -> EXTERN: (398,56) for_trim
  -> EXTERN: (399,14) for_write_seq_fmt_xmit
  -> EXTERN: (399,14) for_write_seq_fmt_xmit
  -> EXTERN: (399,14) for_write_seq_fmt
  -> EXTERN: (400,14) for_write_seq_lis
  -> EXTERN: (401,14) for_write_seq_lis
  -> EXTERN: (402,20) for_trim
  -> EXTERN: (402,36) for_cpstr
  -> EXTERN: (403,14) for_write_seq_lis
  -> EXTERN: (404,14) for_write_seq_lis_xmit
  -> EXTERN: (404,14) for_write_seq_lis
  -> EXTERN: (404,56) for_trim
  -> EXTERN: (405,14) for_write_seq_fmt_xmit
  -> EXTERN: (405,14) for_write_seq_fmt_xmit
  -> EXTERN: (405,14) for_write_seq_fmt
  -> EXTERN: (406,14) for_write_seq_lis
  -> EXTERN: (407,14) for_write_seq_lis
  -> EXTERN: (412,18) for_trim
  -> EXTERN: (412,34) for_cpstr
  -> EXTERN: (412,50) for_trim
  -> EXTERN: (412,66) for_cpstr
  -> EXTERN: (413,17) __resetsp_inlined
  -> EXTERN: (413,17) for_write_seq_fmt_xmit
  -> EXTERN: (413,17) for_write_seq_fmt_xmit
  -> EXTERN: (413,17) _alloca
  -> EXTERN: (413,17) for_write_seq_fmt_xmit
  -> EXTERN: (413,17) for_write_seq_fmt_xmit
  -> EXTERN: (413,17) _alloca
  -> EXTERN: (413,17) for_write_seq_fmt_xmit
  -> EXTERN: (413,17) for_write_seq_fmt_xmit
  -> EXTERN: (413,17) _alloca
  -> EXTERN: (413,17) for_write_seq_fmt_xmit
  -> EXTERN: (413,17) for_write_seq_fmt_xmit
  -> EXTERN: (413,17) for_write_seq_fmt_xmit
  -> EXTERN: (413,17) for_write_seq_fmt
  -> EXTERN: (413,17) __getsp_inlined
  -> EXTERN: (418,30) for_trim
  -> EXTERN: (421,18) for_trim
  -> EXTERN: (421,34) for_cpstr
  -> EXTERN: (421,50) for_trim
  -> EXTERN: (421,66) for_cpstr
  -> EXTERN: (422,17) __resetsp_inlined
  -> EXTERN: (422,17) for_write_seq_fmt_xmit
  -> EXTERN: (422,17) for_write_seq_fmt_xmit
  -> EXTERN: (422,17) for_write_seq_fmt_xmit
  -> EXTERN: (422,17) _alloca
  -> EXTERN: (422,17) for_write_seq_fmt_xmit
  -> EXTERN: (422,17) _alloca
  -> EXTERN: (422,17) for_write_seq_fmt_xmit
  -> EXTERN: (422,17) for_write_seq_fmt_xmit
  -> EXTERN: (422,17) for_write_seq_fmt_xmit
  -> EXTERN: (422,17) for_write_seq_fmt_xmit
  -> EXTERN: (422,17) for_write_seq_fmt
  -> EXTERN: (422,17) __getsp_inlined
  -> EXTERN: (426,24) for_trim
  -> EXTERN: (430,14) for_close
  -> EXTERN: (433,3) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at comm_ptsrc_comp_mod.f90(352,36)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(352,8)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between MAP(:,:) (352:8) and at (352:8)
      remark #17106: parallel dependence: assumed ANTI dependence between at (352:8) and MAP(:,:) (352:8)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between MAP(:,:) (352:8) and at (352:8)
      remark #15346: vector dependence: assumed ANTI dependence between at (352:8) and MAP(:,:) (352:8)

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(352,8)
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed FLOW dependence between MAP(:,:) (352:8) and at (352:8)
         remark #17106: parallel dependence: assumed ANTI dependence between at (352:8) and MAP(:,:) (352:8)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed FLOW dependence between MAP(:,:) (352:8) and at (352:8)
         remark #15346: vector dependence: assumed ANTI dependence between at (352:8) and MAP(:,:) (352:8)
         remark #25439: unrolled with remainder by 2  
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(352,8)
      <Remainder>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(365,16)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(365,16)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(365,16)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference at (365:89) has aligned access   [ comm_ptsrc_comp_mod.f90(365,89) ]
      remark #15388: vectorization support: reference self(:,:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.667
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 6 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 1.930 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(365,16)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(365,16)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(367,11)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 2 3 1 ) 
   remark #25084: Preprocess Loopnests: Moving Out Store    [ comm_ptsrc_comp_mod.f90(371,11) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(368,14)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(369,17)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(369,17)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference self(i,:,j) has aligned access
         remark #15329: vectorization support: non-unit strided store was emulated for the variable <THETA(i,j,:)>, stride is unknown to compiler
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.833
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15453: unmasked strided stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 3.000 
         remark #15478: estimated potential speedup: 1.310 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(369,17)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at comm_ptsrc_comp_mod.f90(410,8)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(413,17)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (413:17) and at (413:17)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (413:17) and at (413:17)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(413,17)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (415:51) has aligned access   [ comm_ptsrc_comp_mod.f90(415,51) ]
         remark #15389: vectorization support: reference self(i,:,1) has unaligned access   [ comm_ptsrc_comp_mod.f90(415,51) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 0.750
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 1.770 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(413,17)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(413,17)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (413:17) and at (413:17)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (413:17) and at (413:17)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(413,17)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (416:51) has aligned access   [ comm_ptsrc_comp_mod.f90(416,51) ]
         remark #15389: vectorization support: reference self(i,:,2) has unaligned access   [ comm_ptsrc_comp_mod.f90(416,51) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 0.750
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 1.770 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(413,17)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(413,17)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (413:17) and at (413:17)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (413:17) and at (413:17)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(413,17)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (417:51) has aligned access   [ comm_ptsrc_comp_mod.f90(417,51) ]
         remark #15389: vectorization support: reference self(i,:,3) has unaligned access   [ comm_ptsrc_comp_mod.f90(417,51) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 0.750
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 1.770 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(413,17)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(422,17)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (422:17) and at (422:17)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (422:17) and at (422:17)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(422,17)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (424:75) has aligned access   [ comm_ptsrc_comp_mod.f90(424,75) ]
         remark #15389: vectorization support: reference self(i,:,1) has unaligned access   [ comm_ptsrc_comp_mod.f90(424,75) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 0.750
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 1.770 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(422,17)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END

   LOOP BEGIN at comm_ptsrc_comp_mod.f90(422,17)
      remark #25399: memcopy generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (422:17) and at (422:17)
      remark #17106: parallel dependence: assumed OUTPUT dependence between at (422:17) and at (422:17)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(422,17)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #15388: vectorization support: reference at (425:24) has aligned access   [ comm_ptsrc_comp_mod.f90(425,24) ]
         remark #15389: vectorization support: reference self(i,:,1) has unaligned access   [ comm_ptsrc_comp_mod.f90(425,24) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 0.750
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 1.770 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at comm_ptsrc_comp_mod.f90(422,17)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

comm_ptsrc_comp_mod.f90(347,48):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
comm_ptsrc_comp_mod.f90(422,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(422,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(422,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(422,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(422,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(422,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(413,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(413,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(413,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(413,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(413,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(413,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(413,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(413,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(413,17):remark #34026: call to memcpy implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(385,94):remark #34014: optimization advice for memmove: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(385,94):remark #34026: call to memmove implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(392,93):remark #34014: optimization advice for memmove: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
comm_ptsrc_comp_mod.f90(392,93):remark #34026: call to memmove implemented as a call to optimized library version
comm_ptsrc_comp_mod.f90(333,14):remark #34051: REGISTER ALLOCATION : [comm_ptsrc_comp_mod_mp_dumpptsrctofits_] comm_ptsrc_comp_mod.f90:333

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm6]
        
    Routine temporaries
        Total         :    1490
            Global    :     312
            Local     :    1178
        Regenerable   :     607
        Spilled       :      50
        
    Routine stack
        Variables     :   16718 bytes*
            Reads     :      46 [1.73e+02 ~ 4.0%]
            Writes    :     249 [3.90e+02 ~ 9.1%]
        Spills        :     360 bytes*
            Reads     :      74 [2.48e+02 ~ 5.8%]
            Writes    :      50 [5.43e+01 ~ 1.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

    Report from: Interprocedural optimizations [ipo]

INLINING FOOTNOTES:

<1> Inlining this subprogram at this call site would increase the size of the 
    caller more than is currently acceptable. Use the option 
    -inline-max-total-size to increase the size that all subprograms can 
    grow through inlining, add "!DIR$ATTRIBUTES OPTIMIZATION_PARAMETER:
    "INLINE_MAX_PER_ROUTINE"" to the caller, add "!DIR$ATTRIBUTES FORCEINLINE"
    to the declaration of the called subprogram, or add "!DIR$ FORCEINLINE" 
    before the call site.

<2> The indirectly called subprogram must be resolved to its targets before it 
can be inlined.  Consider compiling with -ipo or -prof-gen followed by 
-prof-use.

<3> The subprogram is larger than the inliner would normally inline.  Use the
    option -inline-max-size to increase the size of any subprogram that would
    normally be inlined, add "!DIR$ATTRIBUTES FORCEINLINE" to the
    declaration of the called function, or add "!DIR$ FORCEINLINE" before
    the call site.

<4> The compiler's heuristics predict that it is not profitable to inline the
    call.  Add "!DIR$ATTRIBUTES FORCEINLINE" to the declaration of the called 
    subprogram, or add "!DIR$ FORCEINLINE" before the call site.

